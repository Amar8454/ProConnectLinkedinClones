{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 7, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/lenovo/Desktop/LinkdinClone/frontend/node_modules/next/src/server/dev/hot-reloader-types.ts"],"sourcesContent":["import type { IncomingMessage, ServerResponse } from 'http'\nimport type { UrlObject } from 'url'\nimport type { Duplex } from 'stream'\nimport type { webpack } from 'next/dist/compiled/webpack/webpack'\nimport type getBaseWebpackConfig from '../../build/webpack-config'\nimport type { RouteDefinition } from '../route-definitions/route-definition'\nimport type { Project, Update as TurbopackUpdate } from '../../build/swc/types'\nimport type { VersionInfo } from './parse-version-info'\nimport type { DebugInfo } from '../../next-devtools/shared/types'\nimport type { DevIndicatorServerState } from './dev-indicator-server-state'\n\nexport const enum HMR_ACTIONS_SENT_TO_BROWSER {\n  ADDED_PAGE = 'addedPage',\n  REMOVED_PAGE = 'removedPage',\n  RELOAD_PAGE = 'reloadPage',\n  SERVER_COMPONENT_CHANGES = 'serverComponentChanges',\n  MIDDLEWARE_CHANGES = 'middlewareChanges',\n  CLIENT_CHANGES = 'clientChanges',\n  SERVER_ONLY_CHANGES = 'serverOnlyChanges',\n  SYNC = 'sync',\n  BUILT = 'built',\n  BUILDING = 'building',\n  DEV_PAGES_MANIFEST_UPDATE = 'devPagesManifestUpdate',\n  TURBOPACK_MESSAGE = 'turbopack-message',\n  SERVER_ERROR = 'serverError',\n  TURBOPACK_CONNECTED = 'turbopack-connected',\n  ISR_MANIFEST = 'isrManifest',\n  DEV_INDICATOR = 'devIndicator',\n}\n\ninterface ServerErrorAction {\n  action: HMR_ACTIONS_SENT_TO_BROWSER.SERVER_ERROR\n  errorJSON: string\n}\n\nexport interface TurbopackMessageAction {\n  action: HMR_ACTIONS_SENT_TO_BROWSER.TURBOPACK_MESSAGE\n  data: TurbopackUpdate | TurbopackUpdate[]\n}\n\ninterface BuildingAction {\n  action: HMR_ACTIONS_SENT_TO_BROWSER.BUILDING\n}\n\nexport interface CompilationError {\n  moduleName?: string\n  message: string\n  details?: string\n  moduleTrace?: Array<{ moduleName?: string }>\n  stack?: string\n}\nexport interface SyncAction {\n  action: HMR_ACTIONS_SENT_TO_BROWSER.SYNC\n  hash: string\n  errors: ReadonlyArray<CompilationError>\n  warnings: ReadonlyArray<CompilationError>\n  versionInfo: VersionInfo\n  updatedModules?: ReadonlyArray<string>\n  debug?: DebugInfo\n  devIndicator: DevIndicatorServerState\n}\ninterface BuiltAction {\n  action: HMR_ACTIONS_SENT_TO_BROWSER.BUILT\n  hash: string\n  errors: ReadonlyArray<CompilationError>\n  warnings: ReadonlyArray<CompilationError>\n  updatedModules?: ReadonlyArray<string>\n}\n\ninterface AddedPageAction {\n  action: HMR_ACTIONS_SENT_TO_BROWSER.ADDED_PAGE\n  data: [page: string | null]\n}\n\ninterface RemovedPageAction {\n  action: HMR_ACTIONS_SENT_TO_BROWSER.REMOVED_PAGE\n  data: [page: string | null]\n}\n\nexport interface ReloadPageAction {\n  action: HMR_ACTIONS_SENT_TO_BROWSER.RELOAD_PAGE\n  data: string\n}\n\ninterface ServerComponentChangesAction {\n  action: HMR_ACTIONS_SENT_TO_BROWSER.SERVER_COMPONENT_CHANGES\n  hash: string\n}\n\ninterface MiddlewareChangesAction {\n  event: HMR_ACTIONS_SENT_TO_BROWSER.MIDDLEWARE_CHANGES\n}\n\ninterface ClientChangesAction {\n  event: HMR_ACTIONS_SENT_TO_BROWSER.CLIENT_CHANGES\n}\n\ninterface ServerOnlyChangesAction {\n  event: HMR_ACTIONS_SENT_TO_BROWSER.SERVER_ONLY_CHANGES\n  pages: ReadonlyArray<string>\n}\n\ninterface DevPagesManifestUpdateAction {\n  action: HMR_ACTIONS_SENT_TO_BROWSER.DEV_PAGES_MANIFEST_UPDATE\n  data: [\n    {\n      devPagesManifest: true\n    },\n  ]\n}\n\nexport interface TurbopackConnectedAction {\n  action: HMR_ACTIONS_SENT_TO_BROWSER.TURBOPACK_CONNECTED\n  data: { sessionId: number }\n}\n\nexport interface AppIsrManifestAction {\n  action: HMR_ACTIONS_SENT_TO_BROWSER.ISR_MANIFEST\n  data: Record<string, boolean>\n}\n\nexport interface DevIndicatorAction {\n  action: HMR_ACTIONS_SENT_TO_BROWSER.DEV_INDICATOR\n  devIndicator: DevIndicatorServerState\n}\n\nexport type HMR_ACTION_TYPES =\n  | TurbopackMessageAction\n  | TurbopackConnectedAction\n  | BuildingAction\n  | SyncAction\n  | BuiltAction\n  | AddedPageAction\n  | RemovedPageAction\n  | ReloadPageAction\n  | ServerComponentChangesAction\n  | ClientChangesAction\n  | MiddlewareChangesAction\n  | ServerOnlyChangesAction\n  | DevPagesManifestUpdateAction\n  | ServerErrorAction\n  | AppIsrManifestAction\n  | DevIndicatorAction\n\nexport type TurbopackMsgToBrowser =\n  | { type: HMR_ACTIONS_SENT_TO_BROWSER.TURBOPACK_MESSAGE; data: any }\n  | {\n      type: HMR_ACTIONS_SENT_TO_BROWSER.TURBOPACK_CONNECTED\n      data: { sessionId: number }\n    }\n\nexport interface NextJsHotReloaderInterface {\n  turbopackProject?: Project\n  activeWebpackConfigs?: Array<Awaited<ReturnType<typeof getBaseWebpackConfig>>>\n  serverStats: webpack.Stats | null\n  edgeServerStats: webpack.Stats | null\n  run(\n    req: IncomingMessage,\n    res: ServerResponse,\n    parsedUrl: UrlObject\n  ): Promise<{ finished?: true }>\n\n  setHmrServerError(error: Error | null): void\n  clearHmrServerError(): void\n  start(): Promise<void>\n  send(action: HMR_ACTION_TYPES): void\n  getCompilationErrors(page: string): Promise<any[]>\n  onHMR(\n    req: IncomingMessage,\n    _socket: Duplex,\n    head: Buffer,\n    onUpgrade: (client: { send(data: string): void }) => void\n  ): void\n  invalidate({\n    reloadAfterInvalidation,\n  }: {\n    reloadAfterInvalidation: boolean\n  }): Promise<void> | void\n  buildFallbackError(): Promise<void>\n  ensurePage({\n    page,\n    clientOnly,\n    appPaths,\n    definition,\n    isApp,\n    url,\n  }: {\n    page: string\n    clientOnly: boolean\n    appPaths?: ReadonlyArray<string> | null\n    isApp?: boolean\n    definition: RouteDefinition | undefined\n    url?: string\n  }): Promise<void>\n  close(): void\n}\n"],"names":["HMR_ACTIONS_SENT_TO_BROWSER"],"mappings":";;;+BAWkBA,+BAAAA;;;eAAAA;;;AAAX,IAAWA,8BAAAA,WAAAA,GAAAA,SAAAA,2BAAAA;;;;;;;;;;;;;;;;;WAAAA","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 41, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/lenovo/Desktop/LinkdinClone/frontend/node_modules/next/src/server/dev/node-stack-frames.ts"],"sourcesContent":["import { parse } from 'next/dist/compiled/stacktrace-parser'\nimport type { StackFrame } from 'next/dist/compiled/stacktrace-parser'\nimport {\n  decorateServerError,\n  type ErrorSourceType,\n} from '../../shared/lib/error-source'\n\nfunction getFilesystemFrame(frame: StackFrame): StackFrame {\n  const f: StackFrame = { ...frame }\n\n  if (typeof f.file === 'string') {\n    if (\n      // Posix:\n      f.file.startsWith('/') ||\n      // Win32:\n      /^[a-z]:\\\\/i.test(f.file) ||\n      // Win32 UNC:\n      f.file.startsWith('\\\\\\\\')\n    ) {\n      f.file = `file://${f.file}`\n    }\n  }\n\n  return f\n}\n\nexport function getServerError(error: Error, type: ErrorSourceType): Error {\n  if (error.name === 'TurbopackInternalError') {\n    // If this is an internal Turbopack error we shouldn't show internal details\n    // to the user. These are written to a log file instead.\n    const turbopackInternalError = new Error(\n      'An unexpected Turbopack error occurred. Please see the output of `next dev` for more details.'\n    )\n    decorateServerError(turbopackInternalError, type)\n    return turbopackInternalError\n  }\n\n  let n: Error\n  try {\n    throw new Error(error.message)\n  } catch (e) {\n    n = e as Error\n  }\n\n  n.name = error.name\n  try {\n    n.stack = `${n.toString()}\\n${parse(error.stack!)\n      .map(getFilesystemFrame)\n      .map((f) => {\n        let str = `    at ${f.methodName}`\n        if (f.file) {\n          let loc = f.file\n          if (f.lineNumber) {\n            loc += `:${f.lineNumber}`\n            if (f.column) {\n              loc += `:${f.column}`\n            }\n          }\n          str += ` (${loc})`\n        }\n        return str\n      })\n      .join('\\n')}`\n  } catch {\n    n.stack = error.stack\n  }\n\n  decorateServerError(n, type)\n  return n\n}\n"],"names":["getServerError","getFilesystemFrame","frame","f","file","startsWith","test","error","type","name","turbopackInternalError","Error","decorateServerError","n","message","e","stack","toString","parse","map","str","methodName","loc","lineNumber","column","join"],"mappings":";;;+BA0BgBA,kBAAAA;;;eAAAA;;;kCA1BM;6BAKf;AAEP,SAASC,mBAAmBC,KAAiB;IAC3C,MAAMC,IAAgB;QAAE,GAAGD,KAAK;IAAC;IAEjC,IAAI,OAAOC,EAAEC,IAAI,KAAK,UAAU;QAC9B,IACE,AACAD,EAAEC,IAAI,CAACC,EADE,QACQ,CAAC,QAClB,SAAS;QACT,aAAaC,IAAI,CAACH,EAAEC,IAAI,KACxB,aAAa;QACbD,EAAEC,IAAI,CAACC,UAAU,CAAC,SAClB;YACAF,EAAEC,IAAI,GAAG,AAAC,OAAO,GAAQ,CAAE,MAARD,EAAEC,IAAI;QAC3B;IACF;IAEA,OAAOD;AACT;AAEO,SAASH,eAAeO,KAAY,EAAEC,IAAqB;IAChE,IAAID,MAAME,IAAI,KAAK,0BAA0B;QAC3C,4EAA4E;QAC5E,wDAAwD;QACxD,MAAMC,yBAAyB,OAAA,cAE9B,CAF8B,IAAIC,MACjC,kGAD6B,qBAAA;mBAAA;wBAAA;0BAAA;QAE/B;QACAC,CAAAA,GAAAA,aAAAA,mBAAmB,EAACF,wBAAwBF;QAC5C,OAAOE;IACT;IAEA,IAAIG;IACJ,IAAI;QACF,MAAM,OAAA,cAAwB,CAAxB,IAAIF,MAAMJ,MAAMO,OAAO,GAAvB,qBAAA;mBAAA;wBAAA;0BAAA;QAAuB;IAC/B,EAAE,OAAOC,GAAG;QACVF,IAAIE;IACN;IAEAF,EAAEJ,IAAI,GAAGF,MAAME,IAAI;IACnB,IAAI;QACFI,EAAEG,KAAK,GAAG,UAAGH,EAAEI,QAAQ,IAAG,EAAE,IAgBpB,CAAO,MAhBeC,CAAAA,GAAAA,kBAAAA,KAAK,EAACX,MAAMS,KAAK,EAC5CG,GAAG,CAAClB,oBACJkB,GAAG,CAAC,CAAChB;YACJ,IAAIiB,MAAM,AAAC,OAAO,GAAc,CAAE,MAAdjB,EAAEkB,UAAU;YAChC,IAAIlB,EAAEC,IAAI,EAAE;gBACV,IAAIkB,MAAMnB,EAAEC,IAAI;gBAChB,IAAID,EAAEoB,UAAU,EAAE;oBAChBD,OAAO,AAAC,CAAC,GAAc,CAAE,MAAdnB,EAAEoB,UAAU;oBACvB,IAAIpB,EAAEqB,MAAM,EAAE;wBACZF,OAAO,AAAC,CAAC,GAAU,CAAE,MAAVnB,EAAEqB,MAAM;oBACrB;gBACF;gBACAJ,OAAO,AAAC,EAAE,UAAEE,KAAI,CAAC,CAAC;YACpB;YACA,OAAOF;QACT,GACCK,IAAI,CAAC;IACV,EAAE,UAAM;QACNZ,EAAEG,KAAK,GAAGT,MAAMS,KAAK;IACvB;IAEAJ,CAAAA,GAAAA,aAAAA,mBAAmB,EAACC,GAAGL;IACvB,OAAOK;AACT","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 115, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/lenovo/Desktop/LinkdinClone/frontend/node_modules/next/src/server/web/spec-extension/cookies.ts"],"sourcesContent":["export {\n  RequestCookies,\n  ResponseCookies,\n  stringifyCookie,\n} from 'next/dist/compiled/@edge-runtime/cookies'\n"],"names":["RequestCookies","ResponseCookies","stringifyCookie"],"mappings":";;;;;;;;;;;;;;;IACEA,cAAc,EAAA;eAAdA,SAAAA,cAAc;;IACdC,eAAe,EAAA;eAAfA,SAAAA,eAAe;;IACfC,eAAe,EAAA;eAAfA,SAAAA,eAAe;;;yBACV","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 147, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/lenovo/Desktop/LinkdinClone/frontend/node_modules/next/src/server/web/spec-extension/adapters/reflect.ts"],"sourcesContent":["export class ReflectAdapter {\n  static get<T extends object>(\n    target: T,\n    prop: string | symbol,\n    receiver: unknown\n  ): any {\n    const value = Reflect.get(target, prop, receiver)\n    if (typeof value === 'function') {\n      return value.bind(target)\n    }\n\n    return value\n  }\n\n  static set<T extends object>(\n    target: T,\n    prop: string | symbol,\n    value: any,\n    receiver: any\n  ): boolean {\n    return Reflect.set(target, prop, value, receiver)\n  }\n\n  static has<T extends object>(target: T, prop: string | symbol): boolean {\n    return Reflect.has(target, prop)\n  }\n\n  static deleteProperty<T extends object>(\n    target: T,\n    prop: string | symbol\n  ): boolean {\n    return Reflect.deleteProperty(target, prop)\n  }\n}\n"],"names":["ReflectAdapter","get","target","prop","receiver","value","Reflect","bind","set","has","deleteProperty"],"mappings":";;;+BAAaA,kBAAAA;;;eAAAA;;;AAAN,MAAMA;IACX,OAAOC,IACLC,MAAS,EACTC,IAAqB,EACrBC,QAAiB,EACZ;QACL,MAAMC,QAAQC,QAAQL,GAAG,CAACC,QAAQC,MAAMC;QACxC,IAAI,OAAOC,UAAU,YAAY;YAC/B,OAAOA,MAAME,IAAI,CAACL;QACpB;QAEA,OAAOG;IACT;IAEA,OAAOG,IACLN,MAAS,EACTC,IAAqB,EACrBE,KAAU,EACVD,QAAa,EACJ;QACT,OAAOE,QAAQE,GAAG,CAACN,QAAQC,MAAME,OAAOD;IAC1C;IAEA,OAAOK,IAAsBP,MAAS,EAAEC,IAAqB,EAAW;QACtE,OAAOG,QAAQG,GAAG,CAACP,QAAQC;IAC7B;IAEA,OAAOO,eACLR,MAAS,EACTC,IAAqB,EACZ;QACT,OAAOG,QAAQI,cAAc,CAACR,QAAQC;IACxC;AACF","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 180, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/lenovo/Desktop/LinkdinClone/frontend/node_modules/next/src/server/app-render/async-local-storage.ts"],"sourcesContent":["import type { AsyncLocalStorage } from 'async_hooks'\n\nconst sharedAsyncLocalStorageNotAvailableError = new Error(\n  'Invariant: AsyncLocalStorage accessed in runtime where it is not available'\n)\n\nclass FakeAsyncLocalStorage<Store extends {}>\n  implements AsyncLocalStorage<Store>\n{\n  disable(): void {\n    throw sharedAsyncLocalStorageNotAvailableError\n  }\n\n  getStore(): Store | undefined {\n    // This fake implementation of AsyncLocalStorage always returns `undefined`.\n    return undefined\n  }\n\n  run<R>(): R {\n    throw sharedAsyncLocalStorageNotAvailableError\n  }\n\n  exit<R>(): R {\n    throw sharedAsyncLocalStorageNotAvailableError\n  }\n\n  enterWith(): void {\n    throw sharedAsyncLocalStorageNotAvailableError\n  }\n\n  static bind<T>(fn: T): T {\n    return fn\n  }\n}\n\nconst maybeGlobalAsyncLocalStorage =\n  typeof globalThis !== 'undefined' && (globalThis as any).AsyncLocalStorage\n\nexport function createAsyncLocalStorage<\n  Store extends {},\n>(): AsyncLocalStorage<Store> {\n  if (maybeGlobalAsyncLocalStorage) {\n    return new maybeGlobalAsyncLocalStorage()\n  }\n  return new FakeAsyncLocalStorage()\n}\n\nexport function bindSnapshot<T>(fn: T): T {\n  if (maybeGlobalAsyncLocalStorage) {\n    return maybeGlobalAsyncLocalStorage.bind(fn)\n  }\n  return FakeAsyncLocalStorage.bind(fn)\n}\n\nexport function createSnapshot(): <R, TArgs extends any[]>(\n  fn: (...args: TArgs) => R,\n  ...args: TArgs\n) => R {\n  if (maybeGlobalAsyncLocalStorage) {\n    return maybeGlobalAsyncLocalStorage.snapshot()\n  }\n  return function (fn: any, ...args: any[]) {\n    return fn(...args)\n  }\n}\n"],"names":["bindSnapshot","createAsyncLocalStorage","createSnapshot","sharedAsyncLocalStorageNotAvailableError","Error","FakeAsyncLocalStorage","disable","getStore","undefined","run","exit","enterWith","bind","fn","maybeGlobalAsyncLocalStorage","globalThis","AsyncLocalStorage","snapshot","args"],"mappings":";;;;;;;;;;;;;;;IA+CgBA,YAAY,EAAA;eAAZA;;IATAC,uBAAuB,EAAA;eAAvBA;;IAgBAC,cAAc,EAAA;eAAdA;;;AApDhB,MAAMC,2CAA2C,OAAA,cAEhD,CAFgD,IAAIC,MACnD,+EAD+C,qBAAA;WAAA;gBAAA;kBAAA;AAEjD;AAEA,MAAMC;IAGJC,UAAgB;QACd,MAAMH;IACR;IAEAI,WAA8B;QAC5B,4EAA4E;QAC5E,OAAOC;IACT;IAEAC,MAAY;QACV,MAAMN;IACR;IAEAO,OAAa;QACX,MAAMP;IACR;IAEAQ,YAAkB;QAChB,MAAMR;IACR;IAEA,OAAOS,KAAQC,EAAK,EAAK;QACvB,OAAOA;IACT;AACF;AAEA,MAAMC,+BACJ,OAAOC,eAAe,eAAgBA,WAAmBC,iBAAiB;AAErE,SAASf;IAGd,IAAIa,8BAA8B;QAChC,OAAO,IAAIA;IACb;IACA,OAAO,IAAIT;AACb;AAEO,SAASL,aAAgBa,EAAK;IACnC,IAAIC,8BAA8B;QAChC,OAAOA,6BAA6BF,IAAI,CAACC;IAC3C;IACA,OAAOR,sBAAsBO,IAAI,CAACC;AACpC;AAEO,SAASX;IAId,IAAIY,8BAA8B;QAChC,OAAOA,6BAA6BG,QAAQ;IAC9C;IACA,OAAO,SAAUJ,EAAO;;YAAKK,2BAAH,KAAc;;QACtC,OAAOL,MAAMK;IACf;AACF","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 261, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/lenovo/Desktop/LinkdinClone/frontend/node_modules/next/src/server/app-render/work-async-storage-instance.ts"],"sourcesContent":["import type { WorkAsyncStorage } from './work-async-storage.external'\nimport { createAsyncLocalStorage } from './async-local-storage'\n\nexport const workAsyncStorageInstance: WorkAsyncStorage =\n  createAsyncLocalStorage()\n"],"names":["workAsyncStorageInstance","createAsyncLocalStorage"],"mappings":";;;+BAGaA,4BAAAA;;;eAAAA;;;mCAF2B;AAEjC,MAAMA,2BACXC,CAAAA,GAAAA,mBAAAA,uBAAuB","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 278, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/lenovo/Desktop/LinkdinClone/frontend/node_modules/next/src/server/app-render/work-async-storage.external.ts"],"sourcesContent":["import type { AsyncLocalStorage } from 'async_hooks'\nimport type { IncrementalCache } from '../lib/incremental-cache'\nimport type { FetchMetrics } from '../base-http'\nimport type { FallbackRouteParams } from '../request/fallback-params'\nimport type { DeepReadonly } from '../../shared/lib/deep-readonly'\nimport type { AppSegmentConfig } from '../../build/segment-config/app/app-segment-config'\nimport type { AfterContext } from '../after/after-context'\nimport type { CacheLife } from '../use-cache/cache-life'\n\n// Share the instance module in the next-shared layer\nimport { workAsyncStorageInstance } from './work-async-storage-instance' with { 'turbopack-transition': 'next-shared' }\nimport type { LazyResult } from '../lib/lazy-result'\n\nexport interface WorkStore {\n  readonly isStaticGeneration: boolean\n\n  /**\n   * The page that is being rendered. This relates to the path to the page file.\n   */\n  readonly page: string\n\n  /**\n   * The route that is being rendered. This is the page property without the\n   * trailing `/page` or `/route` suffix.\n   */\n  readonly route: string\n\n  /**\n   * The set of unknown route parameters. Accessing these will be tracked as\n   * a dynamic access.\n   */\n  readonly fallbackRouteParams: FallbackRouteParams | null\n\n  readonly incrementalCache?: IncrementalCache\n  readonly cacheLifeProfiles?: { [profile: string]: CacheLife }\n\n  readonly isOnDemandRevalidate?: boolean\n  readonly isBuildTimePrerendering?: boolean\n\n  /**\n   * This is true when:\n   * - source maps are generated\n   * - source maps are applied\n   * - minification is disabled\n   */\n  readonly hasReadableErrorStacks?: boolean\n\n  readonly isRevalidate?: boolean\n\n  forceDynamic?: boolean\n  fetchCache?: AppSegmentConfig['fetchCache']\n\n  forceStatic?: boolean\n  dynamicShouldError?: boolean\n  pendingRevalidates?: Record<string, Promise<any>>\n  pendingRevalidateWrites?: Array<Promise<void>> // This is like pendingRevalidates but isn't used for deduping.\n  readonly afterContext: AfterContext\n\n  dynamicUsageDescription?: string\n  dynamicUsageStack?: string\n\n  /**\n   * Invalid dynamic usage errors might be caught in userland. We attach them to\n   * the work store to ensure we can still fail the build, or show en error in\n   * dev mode.\n   */\n  // TODO: Collect an array of errors, and throw as AggregateError when\n  // `serializeError` and the Dev Overlay support it.\n  invalidDynamicUsageError?: Error\n\n  nextFetchId?: number\n  pathWasRevalidated?: boolean\n\n  /**\n   * Tags that were revalidated during the current request. They need to be sent\n   * to cache handlers to propagate their revalidation.\n   */\n  pendingRevalidatedTags?: string[]\n\n  /**\n   * Tags that were previously revalidated (e.g. by a redirecting server action)\n   * and have already been sent to cache handlers. Retrieved cache entries that\n   * include any of these tags must be discarded.\n   */\n  readonly previouslyRevalidatedTags: readonly string[]\n\n  /**\n   * This map contains lazy results so that we can evaluate them when the first\n   * cache entry is read. It allows us to skip refreshing tags if no caches are\n   * read at all.\n   */\n  readonly refreshTagsByCacheKind: Map<string, LazyResult<void>>\n\n  fetchMetrics?: FetchMetrics\n\n  isDraftMode?: boolean\n  isUnstableNoStore?: boolean\n  isPrefetchRequest?: boolean\n\n  requestEndedState?: { ended?: boolean }\n\n  buildId: string\n\n  readonly reactLoadableManifest?: DeepReadonly<\n    Record<string, { files: string[] }>\n  >\n  readonly assetPrefix?: string\n\n  dynamicIOEnabled: boolean\n  dev: boolean\n\n  /**\n   * Run the given function inside a clean AsyncLocalStorage snapshot. This is\n   * useful when generating cache entries, to ensure that the cache generation\n   * cannot read anything from the context we're currently executing in, which\n   * might include request-specific things like `cookies()` inside a\n   * `React.cache()`.\n   */\n  runInCleanSnapshot: <R, TArgs extends any[]>(\n    fn: (...args: TArgs) => R,\n    ...args: TArgs\n  ) => R\n}\n\nexport type WorkAsyncStorage = AsyncLocalStorage<WorkStore>\n\nexport { workAsyncStorageInstance as workAsyncStorage }\n"],"names":["workAsyncStorage","workAsyncStorageInstance"],"mappings":";;;+BA8HqCA,oBAAAA;;;eAA5BC,0BAAAA,wBAAwB;;;0CApHQ","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 294, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/lenovo/Desktop/LinkdinClone/frontend/node_modules/next/src/server/app-render/work-unit-async-storage-instance.ts"],"sourcesContent":["import { createAsyncLocalStorage } from './async-local-storage'\nimport type { WorkUnitAsyncStorage } from './work-unit-async-storage.external'\n\nexport const workUnitAsyncStorageInstance: WorkUnitAsyncStorage =\n  createAsyncLocalStorage()\n"],"names":["workUnitAsyncStorageInstance","createAsyncLocalStorage"],"mappings":";;;+BAGaA,gCAAAA;;;eAAAA;;;mCAH2B;AAGjC,MAAMA,+BACXC,CAAAA,GAAAA,mBAAAA,uBAAuB","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 311, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/lenovo/Desktop/LinkdinClone/frontend/node_modules/next/src/server/app-render/work-unit-async-storage.external.ts"],"sourcesContent":["import type { AsyncLocalStorage } from 'async_hooks'\nimport type { DraftModeProvider } from '../async-storage/draft-mode-provider'\nimport type { ResponseCookies } from '../web/spec-extension/cookies'\nimport type { ReadonlyHeaders } from '../web/spec-extension/adapters/headers'\nimport type { ReadonlyRequestCookies } from '../web/spec-extension/adapters/request-cookies'\nimport type { CacheSignal } from './cache-signal'\nimport type { DynamicTrackingState } from './dynamic-rendering'\n\n// Share the instance module in the next-shared layer\nimport { workUnitAsyncStorageInstance } from './work-unit-async-storage-instance' with { 'turbopack-transition': 'next-shared' }\nimport type { ServerComponentsHmrCache } from '../response-cache'\nimport type {\n  RenderResumeDataCache,\n  PrerenderResumeDataCache,\n} from '../resume-data-cache/resume-data-cache'\nimport type { Params } from '../request/params'\nimport type { ImplicitTags } from '../lib/implicit-tags'\nimport type { WorkStore } from './work-async-storage.external'\nimport { NEXT_HMR_REFRESH_HASH_COOKIE } from '../../client/components/app-router-headers'\n\nexport type WorkUnitPhase = 'action' | 'render' | 'after'\n\nexport interface CommonWorkUnitStore {\n  /** NOTE: Will be mutated as phases change */\n  phase: WorkUnitPhase\n  readonly implicitTags: ImplicitTags\n}\n\nexport interface RequestStore extends CommonWorkUnitStore {\n  type: 'request'\n\n  /**\n   * The URL of the request. This only specifies the pathname and the search\n   * part of the URL.\n   */\n  readonly url: {\n    /**\n     * The pathname of the requested URL.\n     */\n    readonly pathname: string\n\n    /**\n     * The search part of the requested URL. If the request did not provide a\n     * search part, this will be an empty string.\n     */\n    readonly search: string\n  }\n\n  readonly headers: ReadonlyHeaders\n  // This is mutable because we need to reassign it when transitioning from the action phase to the render phase.\n  // The cookie object itself is deliberately read only and thus can't be updated.\n  cookies: ReadonlyRequestCookies\n  readonly mutableCookies: ResponseCookies\n  readonly userspaceMutableCookies: ResponseCookies\n  readonly draftMode: DraftModeProvider\n  readonly isHmrRefresh?: boolean\n  readonly serverComponentsHmrCache?: ServerComponentsHmrCache\n\n  readonly rootParams: Params\n\n  /**\n   * The resume data cache for this request. This will be a immutable cache.\n   */\n  renderResumeDataCache: RenderResumeDataCache | null\n\n  // DEV-only\n  usedDynamic?: boolean\n  prerenderPhase?: boolean\n}\n\n/**\n * The Prerender store is for tracking information related to prerenders.\n *\n * It can be used for both RSC and SSR prerendering and should be scoped as close\n * to the individual `renderTo...` API call as possible. To keep the type simple\n * we don't distinguish between RSC and SSR prerendering explicitly but instead\n * use conditional object properties to infer which mode we are in. For instance cache tracking\n * only needs to happen during the RSC prerender when we are prospectively prerendering\n * to fill all caches.\n */\nexport interface PrerenderStoreModern extends CommonWorkUnitStore {\n  // In the future the prerender-client variant will get it's own type.\n  // prerender represents the RSC scope of the prerender.\n  // prerender-client represents the HTML scope of the prerender.\n  type: 'prerender' | 'prerender-client'\n\n  /**\n   * This signal is aborted when the React render is complete. (i.e. it is the same signal passed to react)\n   */\n  readonly renderSignal: AbortSignal\n  /**\n   * This is the AbortController which represents the boundary between Prerender and dynamic. In some renders it is\n   * the same as the controller for the renderSignal but in others it is a separate controller. It should be aborted\n   * whenever the we are no longer in the prerender phase of rendering. Typically this is after one task or when you call\n   * a sync API which requires the prerender to end immediately\n   */\n  readonly controller: AbortController\n\n  /**\n   * when not null this signal is used to track cache reads during prerendering and\n   * to await all cache reads completing before aborting the prerender.\n   */\n  readonly cacheSignal: null | CacheSignal\n\n  /**\n   * During some prerenders we want to track dynamic access.\n   */\n  readonly dynamicTracking: null | DynamicTrackingState\n\n  readonly rootParams: Params\n\n  /**\n   * When true, the page is prerendered as a fallback shell, while allowing any\n   * dynamic accesses to result in an empty shell. This is the case when there\n   * are also routes prerendered with a more complete set of params.\n   * Prerendering those routes would catch any invalid dynamic accesses.\n   */\n  readonly allowEmptyStaticShell: boolean\n\n  // Collected revalidate times and tags for this document during the prerender.\n  revalidate: number // in seconds. 0 means dynamic. INFINITE_CACHE and higher means never revalidate.\n  expire: number // server expiration time\n  stale: number // client expiration time\n  tags: null | string[]\n\n  /**\n   * A mutable resume data cache for this prerender.\n   */\n  prerenderResumeDataCache: PrerenderResumeDataCache | null\n\n  /**\n   * An immutable resume data cache for this prerender. This may be provided\n   * instead of the `prerenderResumeDataCache` if the prerender is not supposed\n   * to fill caches, and only read from prefilled caches, e.g. when prerendering\n   * an optional fallback shell.\n   */\n  renderResumeDataCache: RenderResumeDataCache | null\n\n  /**\n   * The HMR refresh hash is only provided in dev mode. It is needed for the dev\n   * warmup render to ensure that the cache keys will be identical for the\n   * subsequent dynamic render.\n   */\n  readonly hmrRefreshHash: string | undefined\n\n  /**\n   * Only available in dev mode.\n   */\n  readonly captureOwnerStack: undefined | (() => string | null)\n}\n\nexport interface PrerenderStorePPR extends CommonWorkUnitStore {\n  type: 'prerender-ppr'\n  readonly rootParams: Params\n  readonly dynamicTracking: null | DynamicTrackingState\n  // Collected revalidate times and tags for this document during the prerender.\n  revalidate: number // in seconds. 0 means dynamic. INFINITE_CACHE and higher means never revalidate.\n  expire: number // server expiration time\n  stale: number // client expiration time\n  tags: null | string[]\n\n  /**\n   * The resume data cache for this prerender.\n   */\n  prerenderResumeDataCache: PrerenderResumeDataCache\n}\n\nexport interface PrerenderStoreLegacy extends CommonWorkUnitStore {\n  type: 'prerender-legacy'\n  readonly rootParams: Params\n  // Collected revalidate times and tags for this document during the prerender.\n  revalidate: number // in seconds. 0 means dynamic. INFINITE_CACHE and higher means never revalidate.\n  expire: number // server expiration time\n  stale: number // client expiration time\n  tags: null | string[]\n}\n\nexport type PrerenderStore =\n  | PrerenderStoreLegacy\n  | PrerenderStorePPR\n  | PrerenderStoreModern\n\nexport interface CommonCacheStore\n  extends Omit<CommonWorkUnitStore, 'implicitTags'> {\n  /**\n   * A cache work unit store might not always have an outer work unit store,\n   * from which implicit tags could be inherited.\n   */\n  readonly implicitTags: ImplicitTags | undefined\n  /**\n   * Draft mode is only available if the outer work unit store is a request\n   * store and draft mode is enabled.\n   */\n  readonly draftMode: DraftModeProvider | undefined\n}\n\nexport interface UseCacheStore extends CommonCacheStore {\n  type: 'cache'\n  // Collected revalidate times and tags for this cache entry during the cache render.\n  revalidate: number // implicit revalidate time from inner caches / fetches\n  expire: number // server expiration time\n  stale: number // client expiration time\n  explicitRevalidate: undefined | number // explicit revalidate time from cacheLife() calls\n  explicitExpire: undefined | number // server expiration time\n  explicitStale: undefined | number // client expiration time\n  tags: null | string[]\n  readonly hmrRefreshHash: string | undefined\n  readonly isHmrRefresh: boolean\n  readonly serverComponentsHmrCache: ServerComponentsHmrCache | undefined\n  readonly forceRevalidate: boolean\n}\n\nexport interface UnstableCacheStore extends CommonCacheStore {\n  type: 'unstable-cache'\n}\n\n/**\n * The Cache store is for tracking information inside a \"use cache\" or\n * unstable_cache context. A cache store shadows an outer request store (if\n * present) as a work unit, so that we never accidentally expose any request or\n * page specific information to cache functions, unless it's explicitly desired.\n * For those exceptions, the data is copied over from the request store to the\n * cache store, instead of generally making the request store available to cache\n * functions.\n */\nexport type CacheStore = UseCacheStore | UnstableCacheStore\n\nexport type WorkUnitStore = RequestStore | CacheStore | PrerenderStore\n\nexport type WorkUnitAsyncStorage = AsyncLocalStorage<WorkUnitStore>\n\nexport { workUnitAsyncStorageInstance as workUnitAsyncStorage }\n\nexport function getExpectedRequestStore(\n  callingExpression: string\n): RequestStore {\n  const workUnitStore = workUnitAsyncStorageInstance.getStore()\n\n  if (!workUnitStore) {\n    throwForMissingRequestStore(callingExpression)\n  }\n\n  switch (workUnitStore.type) {\n    case 'request':\n      return workUnitStore\n\n    case 'prerender':\n    case 'prerender-client':\n    case 'prerender-ppr':\n    case 'prerender-legacy':\n      // This should not happen because we should have checked it already.\n      throw new Error(\n        `\\`${callingExpression}\\` cannot be called inside a prerender. This is a bug in Next.js.`\n      )\n\n    case 'cache':\n      throw new Error(\n        `\\`${callingExpression}\\` cannot be called inside \"use cache\". Call it outside and pass an argument instead. Read more: https://nextjs.org/docs/messages/next-request-in-use-cache`\n      )\n\n    case 'unstable-cache':\n      throw new Error(\n        `\\`${callingExpression}\\` cannot be called inside unstable_cache. Call it outside and pass an argument instead. Read more: https://nextjs.org/docs/app/api-reference/functions/unstable_cache`\n      )\n\n    default:\n      const _exhaustiveCheck: never = workUnitStore\n      return _exhaustiveCheck\n  }\n}\n\nexport function throwForMissingRequestStore(callingExpression: string): never {\n  throw new Error(\n    `\\`${callingExpression}\\` was called outside a request scope. Read more: https://nextjs.org/docs/messages/next-dynamic-api-wrong-context`\n  )\n}\n\nexport function getPrerenderResumeDataCache(\n  workUnitStore: WorkUnitStore\n): PrerenderResumeDataCache | null {\n  if (\n    workUnitStore.type === 'prerender' ||\n    // TODO eliminate fetch caching in client scope and stop exposing this data cache during SSR\n    workUnitStore.type === 'prerender-client' ||\n    workUnitStore.type === 'prerender-ppr'\n  ) {\n    return workUnitStore.prerenderResumeDataCache\n  }\n\n  return null\n}\n\nexport function getRenderResumeDataCache(\n  workUnitStore: WorkUnitStore\n): RenderResumeDataCache | null {\n  switch (workUnitStore.type) {\n    case 'request':\n      return workUnitStore.renderResumeDataCache\n    case 'prerender':\n    case 'prerender-client':\n      if (workUnitStore.renderResumeDataCache) {\n        // If we are in a prerender, we might have a render resume data cache\n        // that is used to read from prefilled caches.\n        return workUnitStore.renderResumeDataCache\n      }\n    // fallthrough\n    case 'prerender-ppr':\n      // Otherwise we return the mutable resume data cache here as an immutable\n      // version of the cache as it can also be used for reading.\n      return workUnitStore.prerenderResumeDataCache\n    default:\n      return null\n  }\n}\n\nexport function getHmrRefreshHash(\n  workStore: WorkStore,\n  workUnitStore: WorkUnitStore\n): string | undefined {\n  if (!workStore.dev) {\n    return undefined\n  }\n\n  return workUnitStore.type === 'cache' || workUnitStore.type === 'prerender'\n    ? workUnitStore.hmrRefreshHash\n    : workUnitStore.type === 'request'\n      ? workUnitStore.cookies.get(NEXT_HMR_REFRESH_HASH_COOKIE)?.value\n      : undefined\n}\n\n/**\n * Returns a draft mode provider only if draft mode is enabled.\n */\nexport function getDraftModeProviderForCacheScope(\n  workStore: WorkStore,\n  workUnitStore: WorkUnitStore\n): DraftModeProvider | undefined {\n  if (workStore.isDraftMode) {\n    switch (workUnitStore.type) {\n      case 'cache':\n      case 'unstable-cache':\n      case 'request':\n        return workUnitStore.draftMode\n      default:\n        return undefined\n    }\n  }\n\n  return undefined\n}\n"],"names":["getDraftModeProviderForCacheScope","getExpectedRequestStore","getHmrRefreshHash","getPrerenderResumeDataCache","getRenderResumeDataCache","throwForMissingRequestStore","workUnitAsyncStorage","workUnitAsyncStorageInstance","callingExpression","workUnitStore","getStore","type","Error","_exhaustiveCheck","prerenderResumeDataCache","renderResumeDataCache","workStore","dev","undefined","hmrRefreshHash","cookies","get","NEXT_HMR_REFRESH_HASH_COOKIE","value","isDraftMode","draftMode"],"mappings":";;;;;;;;;;;;;;;;;;;IA6UgBA,iCAAiC,EAAA;eAAjCA;;IApGAC,uBAAuB,EAAA;eAAvBA;;IAkFAC,iBAAiB,EAAA;eAAjBA;;IAtCAC,2BAA2B,EAAA;eAA3BA;;IAeAC,wBAAwB,EAAA;eAAxBA;;IArBAC,2BAA2B,EAAA;eAA3BA;;IAxCyBC,oBAAoB,EAAA;eAApDC,8BAAAA,4BAA4B;;;8CA9NQ;kCASA;AAuNtC,SAASN,wBACdO,iBAAyB;IAEzB,MAAMC,gBAAgBF,8BAAAA,4BAA4B,CAACG,QAAQ;IAE3D,IAAI,CAACD,eAAe;QAClBJ,4BAA4BG;IAC9B;IAEA,OAAQC,cAAcE,IAAI;QACxB,KAAK;YACH,OAAOF;QAET,KAAK;QACL,KAAK;QACL,KAAK;QACL,KAAK;YACH,oEAAoE;YACpE,MAAM,OAAA,cAEL,CAFK,IAAIG,MACR,AAAC,EAAE,SAAEJ,mBAAkB,iEAAiE,CAAC,IADrF,qBAAA;uBAAA;4BAAA;8BAAA;YAEN;QAEF,KAAK;YACH,MAAM,OAAA,cAEL,CAFK,IAAII,MACR,AAAC,EAAE,SAAEJ,mBAAkB,2JAA2J,CAAC,IAD/K,qBAAA;uBAAA;4BAAA;8BAAA;YAEN;QAEF,KAAK;YACH,MAAM,OAAA,cAEL,CAFK,IAAII,MACR,AAAC,EAAE,SAAEJ,mBAAkB,sKAAsK,CAAC,IAD1L,qBAAA;uBAAA;4BAAA;8BAAA;YAEN;QAEF;YACE,MAAMK,mBAA0BJ;YAChC,OAAOI;IACX;AACF;AAEO,SAASR,4BAA4BG,iBAAyB;IACnE,MAAM,OAAA,cAEL,CAFK,IAAII,MACR,AAAC,EAAE,EAAoB,OAAlBJ,0GAAmI,CAAC,8BADrI,qBAAA;eAAA;oBAAA;sBAAA;IAEN;AACF;AAEO,SAASL,4BACdM,aAA4B;IAE5B,IACEA,cAAcE,IAAI,KAAK,eACvB,4FAA4F;IAC5FF,cAAcE,IAAI,KAAK,sBACvBF,cAAcE,IAAI,KAAK,iBACvB;QACA,OAAOF,cAAcK,wBAAwB;IAC/C;IAEA,OAAO;AACT;AAEO,SAASV,yBACdK,aAA4B;IAE5B,OAAQA,cAAcE,IAAI;QACxB,KAAK;YACH,OAAOF,cAAcM,qBAAqB;QAC5C,KAAK;QACL,KAAK;YACH,IAAIN,cAAcM,qBAAqB,EAAE;gBACvC,qEAAqE;gBACrE,8CAA8C;gBAC9C,OAAON,cAAcM,qBAAqB;YAC5C;QACF,cAAc;QACd,KAAK;YACH,yEAAyE;YACzE,2DAA2D;YAC3D,OAAON,cAAcK,wBAAwB;QAC/C;YACE,OAAO;IACX;AACF;AAEO,SAASZ,kBACdc,SAAoB,EACpBP,aAA4B;QAStBA;IAPN,IAAI,CAACO,UAAUC,GAAG,EAAE;QAClB,OAAOC;IACT;IAEA,OAAOT,cAAcE,IAAI,KAAK,WAAWF,cAAcE,IAAI,KAAK,cAC5DF,cAAcU,cAAc,GAC5BV,cAAcE,IAAI,KAAK,YAAA,CACrBF,6BAAAA,cAAcW,OAAO,CAACC,GAAG,CAACC,kBAAAA,4BAA4B,CAAA,KAAA,OAAA,KAAA,IAAtDb,2BAAyDc,KAAK,GAC9DL;AACR;AAKO,SAASlB,kCACdgB,SAAoB,EACpBP,aAA4B;IAE5B,IAAIO,UAAUQ,WAAW,EAAE;QACzB,OAAQf,cAAcE,IAAI;YACxB,KAAK;YACL,KAAK;YACL,KAAK;gBACH,OAAOF,cAAcgB,SAAS;YAChC;gBACE,OAAOP;QACX;IACF;IAEA,OAAOA;AACT","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 449, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/lenovo/Desktop/LinkdinClone/frontend/node_modules/next/src/server/web/spec-extension/adapters/request-cookies.ts"],"sourcesContent":["import { RequestCookies } from '../cookies'\n\nimport { ResponseCookies } from '../cookies'\nimport { ReflectAdapter } from './reflect'\nimport { workAsyncStorage } from '../../../app-render/work-async-storage.external'\nimport {\n  getExpectedRequestStore,\n  type RequestStore,\n} from '../../../app-render/work-unit-async-storage.external'\n\n/**\n * @internal\n */\nexport class ReadonlyRequestCookiesError extends Error {\n  constructor() {\n    super(\n      'Cookies can only be modified in a Server Action or Route Handler. Read more: https://nextjs.org/docs/app/api-reference/functions/cookies#options'\n    )\n  }\n\n  public static callable() {\n    throw new ReadonlyRequestCookiesError()\n  }\n}\n\n// We use this to type some APIs but we don't construct instances directly\nexport type { ResponseCookies }\n\n// The `cookies()` API is a mix of request and response cookies. For `.get()` methods,\n// we want to return the request cookie if it exists. For mutative methods like `.set()`,\n// we want to return the response cookie.\nexport type ReadonlyRequestCookies = Omit<\n  RequestCookies,\n  'set' | 'clear' | 'delete'\n> &\n  Pick<ResponseCookies, 'set' | 'delete'>\n\nexport class RequestCookiesAdapter {\n  public static seal(cookies: RequestCookies): ReadonlyRequestCookies {\n    return new Proxy(cookies as any, {\n      get(target, prop, receiver) {\n        switch (prop) {\n          case 'clear':\n          case 'delete':\n          case 'set':\n            return ReadonlyRequestCookiesError.callable\n          default:\n            return ReflectAdapter.get(target, prop, receiver)\n        }\n      },\n    })\n  }\n}\n\nconst SYMBOL_MODIFY_COOKIE_VALUES = Symbol.for('next.mutated.cookies')\n\nexport function getModifiedCookieValues(\n  cookies: ResponseCookies\n): ResponseCookie[] {\n  const modified: ResponseCookie[] | undefined = (cookies as unknown as any)[\n    SYMBOL_MODIFY_COOKIE_VALUES\n  ]\n  if (!modified || !Array.isArray(modified) || modified.length === 0) {\n    return []\n  }\n\n  return modified\n}\n\ntype SetCookieArgs =\n  | [key: string, value: string, cookie?: Partial<ResponseCookie>]\n  | [options: ResponseCookie]\n\nexport function appendMutableCookies(\n  headers: Headers,\n  mutableCookies: ResponseCookies\n): boolean {\n  const modifiedCookieValues = getModifiedCookieValues(mutableCookies)\n  if (modifiedCookieValues.length === 0) {\n    return false\n  }\n\n  // Return a new response that extends the response with\n  // the modified cookies as fallbacks. `res` cookies\n  // will still take precedence.\n  const resCookies = new ResponseCookies(headers)\n  const returnedCookies = resCookies.getAll()\n\n  // Set the modified cookies as fallbacks.\n  for (const cookie of modifiedCookieValues) {\n    resCookies.set(cookie)\n  }\n\n  // Set the original cookies as the final values.\n  for (const cookie of returnedCookies) {\n    resCookies.set(cookie)\n  }\n\n  return true\n}\n\ntype ResponseCookie = NonNullable<\n  ReturnType<InstanceType<typeof ResponseCookies>['get']>\n>\n\nexport class MutableRequestCookiesAdapter {\n  public static wrap(\n    cookies: RequestCookies,\n    onUpdateCookies?: (cookies: string[]) => void\n  ): ResponseCookies {\n    const responseCookies = new ResponseCookies(new Headers())\n    for (const cookie of cookies.getAll()) {\n      responseCookies.set(cookie)\n    }\n\n    let modifiedValues: ResponseCookie[] = []\n    const modifiedCookies = new Set<string>()\n    const updateResponseCookies = () => {\n      // TODO-APP: change method of getting workStore\n      const workStore = workAsyncStorage.getStore()\n      if (workStore) {\n        workStore.pathWasRevalidated = true\n      }\n\n      const allCookies = responseCookies.getAll()\n      modifiedValues = allCookies.filter((c) => modifiedCookies.has(c.name))\n      if (onUpdateCookies) {\n        const serializedCookies: string[] = []\n        for (const cookie of modifiedValues) {\n          const tempCookies = new ResponseCookies(new Headers())\n          tempCookies.set(cookie)\n          serializedCookies.push(tempCookies.toString())\n        }\n\n        onUpdateCookies(serializedCookies)\n      }\n    }\n\n    const wrappedCookies = new Proxy(responseCookies, {\n      get(target, prop, receiver) {\n        switch (prop) {\n          // A special symbol to get the modified cookie values\n          case SYMBOL_MODIFY_COOKIE_VALUES:\n            return modifiedValues\n\n          // TODO: Throw error if trying to set a cookie after the response\n          // headers have been set.\n          case 'delete':\n            return function (...args: [string] | [ResponseCookie]) {\n              modifiedCookies.add(\n                typeof args[0] === 'string' ? args[0] : args[0].name\n              )\n              try {\n                target.delete(...args)\n                return wrappedCookies\n              } finally {\n                updateResponseCookies()\n              }\n            }\n          case 'set':\n            return function (...args: SetCookieArgs) {\n              modifiedCookies.add(\n                typeof args[0] === 'string' ? args[0] : args[0].name\n              )\n              try {\n                target.set(...args)\n                return wrappedCookies\n              } finally {\n                updateResponseCookies()\n              }\n            }\n\n          default:\n            return ReflectAdapter.get(target, prop, receiver)\n        }\n      },\n    })\n\n    return wrappedCookies\n  }\n}\n\nexport function wrapWithMutableAccessCheck(\n  responseCookies: ResponseCookies\n): ResponseCookies {\n  const wrappedCookies = new Proxy(responseCookies, {\n    get(target, prop, receiver) {\n      switch (prop) {\n        case 'delete':\n          return function (...args: [string] | [ResponseCookie]) {\n            ensureCookiesAreStillMutable('cookies().delete')\n            target.delete(...args)\n            return wrappedCookies\n          }\n        case 'set':\n          return function (...args: SetCookieArgs) {\n            ensureCookiesAreStillMutable('cookies().set')\n            target.set(...args)\n            return wrappedCookies\n          }\n\n        default:\n          return ReflectAdapter.get(target, prop, receiver)\n      }\n    },\n  })\n  return wrappedCookies\n}\n\nexport function areCookiesMutableInCurrentPhase(requestStore: RequestStore) {\n  return requestStore.phase === 'action'\n}\n\n/** Ensure that cookies() starts throwing on mutation\n * if we changed phases and can no longer mutate.\n *\n * This can happen when going:\n *   'render' -> 'after'\n *   'action' -> 'render'\n * */\nfunction ensureCookiesAreStillMutable(callingExpression: string) {\n  const requestStore = getExpectedRequestStore(callingExpression)\n  if (!areCookiesMutableInCurrentPhase(requestStore)) {\n    // TODO: maybe we can give a more precise error message based on callingExpression?\n    throw new ReadonlyRequestCookiesError()\n  }\n}\n\nexport function responseCookiesToRequestCookies(\n  responseCookies: ResponseCookies\n): RequestCookies {\n  const requestCookies = new RequestCookies(new Headers())\n  for (const cookie of responseCookies.getAll()) {\n    requestCookies.set(cookie)\n  }\n  return requestCookies\n}\n"],"names":["MutableRequestCookiesAdapter","ReadonlyRequestCookiesError","RequestCookiesAdapter","appendMutableCookies","areCookiesMutableInCurrentPhase","getModifiedCookieValues","responseCookiesToRequestCookies","wrapWithMutableAccessCheck","Error","constructor","callable","seal","cookies","Proxy","get","target","prop","receiver","ReflectAdapter","SYMBOL_MODIFY_COOKIE_VALUES","Symbol","for","modified","Array","isArray","length","headers","mutableCookies","modifiedCookieValues","resCookies","ResponseCookies","returnedCookies","getAll","cookie","set","wrap","onUpdateCookies","responseCookies","Headers","modifiedValues","modifiedCookies","Set","updateResponseCookies","workStore","workAsyncStorage","getStore","pathWasRevalidated","allCookies","filter","c","has","name","serializedCookies","tempCookies","push","toString","wrappedCookies","args","add","delete","ensureCookiesAreStillMutable","requestStore","phase","callingExpression","getExpectedRequestStore","requestCookies","RequestCookies"],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 676, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/lenovo/Desktop/LinkdinClone/frontend/node_modules/next/src/server/dynamic-rendering-utils.ts"],"sourcesContent":["export function isHangingPromiseRejectionError(\n  err: unknown\n): err is HangingPromiseRejectionError {\n  if (typeof err !== 'object' || err === null || !('digest' in err)) {\n    return false\n  }\n\n  return err.digest === HANGING_PROMISE_REJECTION\n}\n\nconst HANGING_PROMISE_REJECTION = 'HANGING_PROMISE_REJECTION'\n\nclass HangingPromiseRejectionError extends Error {\n  public readonly digest = HANGING_PROMISE_REJECTION\n\n  constructor(public readonly expression: string) {\n    super(\n      `During prerendering, ${expression} rejects when the prerender is complete. Typically these errors are handled by React but if you move ${expression} to a different context by using \\`setTimeout\\`, \\`after\\`, or similar functions you may observe this error and you should handle it in that context.`\n    )\n  }\n}\n\ntype AbortListeners = Array<(err: unknown) => void>\nconst abortListenersBySignal = new WeakMap<AbortSignal, AbortListeners>()\n\n/**\n * This function constructs a promise that will never resolve. This is primarily\n * useful for dynamicIO where we use promise resolution timing to determine which\n * parts of a render can be included in a prerender.\n *\n * @internal\n */\nexport function makeHangingPromise<T>(\n  signal: AbortSignal,\n  expression: string\n): Promise<T> {\n  if (signal.aborted) {\n    return Promise.reject(new HangingPromiseRejectionError(expression))\n  } else {\n    const hangingPromise = new Promise<T>((_, reject) => {\n      const boundRejection = reject.bind(\n        null,\n        new HangingPromiseRejectionError(expression)\n      )\n      let currentListeners = abortListenersBySignal.get(signal)\n      if (currentListeners) {\n        currentListeners.push(boundRejection)\n      } else {\n        const listeners = [boundRejection]\n        abortListenersBySignal.set(signal, listeners)\n        signal.addEventListener(\n          'abort',\n          () => {\n            for (let i = 0; i < listeners.length; i++) {\n              listeners[i]()\n            }\n          },\n          { once: true }\n        )\n      }\n    })\n    // We are fine if no one actually awaits this promise. We shouldn't consider this an unhandled rejection so\n    // we attach a noop catch handler here to suppress this warning. If you actually await somewhere or construct\n    // your own promise out of it you'll need to ensure you handle the error when it rejects.\n    hangingPromise.catch(ignoreReject)\n    return hangingPromise\n  }\n}\n\nfunction ignoreReject() {}\n"],"names":["isHangingPromiseRejectionError","makeHangingPromise","err","digest","HANGING_PROMISE_REJECTION","HangingPromiseRejectionError","Error","constructor","expression","abortListenersBySignal","WeakMap","signal","aborted","Promise","reject","hangingPromise","_","boundRejection","bind","currentListeners","get","push","listeners","set","addEventListener","i","length","once","catch","ignoreReject"],"mappings":";;;;;;;;;;;;;;IAAgBA,8BAA8B,EAAA;eAA9BA;;IAgCAC,kBAAkB,EAAA;eAAlBA;;;AAhCT,SAASD,+BACdE,GAAY;IAEZ,IAAI,OAAOA,QAAQ,YAAYA,QAAQ,QAAQ,CAAE,CAAA,YAAYA,GAAE,GAAI;QACjE,OAAO;IACT;IAEA,OAAOA,IAAIC,MAAM,KAAKC;AACxB;AAEA,MAAMA,4BAA4B;AAElC,MAAMC,qCAAqCC;IAGzCC,YAA4BC,UAAkB,CAAE;QAC9C,KAAK,CACH,AAAC,qBAAqB,UAAEA,YAAW,qGAAqG,WAAEA,YAAW,qJAAqJ,CAAC,CAAA,IAAA,CAFnRA,UAAAA,GAAAA,YAAAA,IAAAA,CAFZL,MAAAA,GAASC;IAMzB;AACF;AAGA,MAAMK,yBAAyB,IAAIC;AAS5B,SAAST,mBACdU,MAAmB,EACnBH,UAAkB;IAElB,IAAIG,OAAOC,OAAO,EAAE;QAClB,OAAOC,QAAQC,MAAM,CAAC,IAAIT,6BAA6BG;IACzD,OAAO;QACL,MAAMO,iBAAiB,IAAIF,QAAW,CAACG,GAAGF;YACxC,MAAMG,iBAAiBH,OAAOI,IAAI,CAChC,MACA,IAAIb,6BAA6BG;YAEnC,IAAIW,mBAAmBV,uBAAuBW,GAAG,CAACT;YAClD,IAAIQ,kBAAkB;gBACpBA,iBAAiBE,IAAI,CAACJ;YACxB,OAAO;gBACL,MAAMK,YAAY;oBAACL;iBAAe;gBAClCR,uBAAuBc,GAAG,CAACZ,QAAQW;gBACnCX,OAAOa,gBAAgB,CACrB,SACA;oBACE,IAAK,IAAIC,IAAI,GAAGA,IAAIH,UAAUI,MAAM,EAAED,IAAK;wBACzCH,SAAS,CAACG,EAAE;oBACd;gBACF,GACA;oBAAEE,MAAM;gBAAK;YAEjB;QACF;QACA,2GAA2G;QAC3G,6GAA6G;QAC7G,yFAAyF;QACzFZ,eAAea,KAAK,CAACC;QACrB,OAAOd;IACT;AACF;AAEA,SAASc,gBAAgB","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 747, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/lenovo/Desktop/LinkdinClone/frontend/node_modules/next/src/server/app-render/dynamic-rendering.ts"],"sourcesContent":["/**\n * The functions provided by this module are used to communicate certain properties\n * about the currently running code so that Next.js can make decisions on how to handle\n * the current execution in different rendering modes such as pre-rendering, resuming, and SSR.\n *\n * Today Next.js treats all code as potentially static. Certain APIs may only make sense when dynamically rendering.\n * Traditionally this meant deopting the entire render to dynamic however with PPR we can now deopt parts\n * of a React tree as dynamic while still keeping other parts static. There are really two different kinds of\n * Dynamic indications.\n *\n * The first is simply an intention to be dynamic. unstable_noStore is an example of this where\n * the currently executing code simply declares that the current scope is dynamic but if you use it\n * inside unstable_cache it can still be cached. This type of indication can be removed if we ever\n * make the default dynamic to begin with because the only way you would ever be static is inside\n * a cache scope which this indication does not affect.\n *\n * The second is an indication that a dynamic data source was read. This is a stronger form of dynamic\n * because it means that it is inappropriate to cache this at all. using a dynamic data source inside\n * unstable_cache should error. If you want to use some dynamic data inside unstable_cache you should\n * read that data outside the cache and pass it in as an argument to the cached function.\n */\n\nimport type { WorkStore } from '../app-render/work-async-storage.external'\nimport type {\n  WorkUnitStore,\n  RequestStore,\n  PrerenderStoreLegacy,\n  PrerenderStoreModern,\n} from '../app-render/work-unit-async-storage.external'\n\n// Once postpone is in stable we should switch to importing the postpone export directly\nimport React from 'react'\n\nimport { DynamicServerError } from '../../client/components/hooks-server-context'\nimport { StaticGenBailoutError } from '../../client/components/static-generation-bailout'\nimport { workUnitAsyncStorage } from './work-unit-async-storage.external'\nimport { workAsyncStorage } from '../app-render/work-async-storage.external'\nimport { makeHangingPromise } from '../dynamic-rendering-utils'\nimport {\n  METADATA_BOUNDARY_NAME,\n  VIEWPORT_BOUNDARY_NAME,\n  OUTLET_BOUNDARY_NAME,\n} from '../../lib/metadata/metadata-constants'\nimport { scheduleOnNextTick } from '../../lib/scheduler'\n\nconst hasPostpone = typeof React.unstable_postpone === 'function'\n\nexport type DynamicAccess = {\n  /**\n   * If debugging, this will contain the stack trace of where the dynamic access\n   * occurred. This is used to provide more information to the user about why\n   * their page is being rendered dynamically.\n   */\n  stack?: string\n\n  /**\n   * The expression that was accessed dynamically.\n   */\n  expression: string\n}\n\n// Stores dynamic reasons used during an RSC render.\nexport type DynamicTrackingState = {\n  /**\n   * When true, stack information will also be tracked during dynamic access.\n   */\n  readonly isDebugDynamicAccesses: boolean | undefined\n\n  /**\n   * The dynamic accesses that occurred during the render.\n   */\n  readonly dynamicAccesses: Array<DynamicAccess>\n\n  syncDynamicErrorWithStack: null | Error\n}\n\n// Stores dynamic reasons used during an SSR render.\nexport type DynamicValidationState = {\n  hasSuspenseAboveBody: boolean\n  hasDynamicMetadata: boolean\n  hasDynamicViewport: boolean\n  hasAllowedDynamic: boolean\n  dynamicErrors: Array<Error>\n}\n\nexport function createDynamicTrackingState(\n  isDebugDynamicAccesses: boolean | undefined\n): DynamicTrackingState {\n  return {\n    isDebugDynamicAccesses,\n    dynamicAccesses: [],\n    syncDynamicErrorWithStack: null,\n  }\n}\n\nexport function createDynamicValidationState(): DynamicValidationState {\n  return {\n    hasSuspenseAboveBody: false,\n    hasDynamicMetadata: false,\n    hasDynamicViewport: false,\n    hasAllowedDynamic: false,\n    dynamicErrors: [],\n  }\n}\n\nexport function getFirstDynamicReason(\n  trackingState: DynamicTrackingState\n): undefined | string {\n  return trackingState.dynamicAccesses[0]?.expression\n}\n\n/**\n * This function communicates that the current scope should be treated as dynamic.\n *\n * In most cases this function is a no-op but if called during\n * a PPR prerender it will postpone the current sub-tree and calling\n * it during a normal prerender will cause the entire prerender to abort\n */\nexport function markCurrentScopeAsDynamic(\n  store: WorkStore,\n  workUnitStore: undefined | Exclude<WorkUnitStore, PrerenderStoreModern>,\n  expression: string\n): void {\n  if (workUnitStore) {\n    if (\n      workUnitStore.type === 'cache' ||\n      workUnitStore.type === 'unstable-cache'\n    ) {\n      // inside cache scopes marking a scope as dynamic has no effect because the outer cache scope\n      // creates a cache boundary. This is subtly different from reading a dynamic data source which is\n      // forbidden inside a cache scope.\n      return\n    }\n  }\n\n  // If we're forcing dynamic rendering or we're forcing static rendering, we\n  // don't need to do anything here because the entire page is already dynamic\n  // or it's static and it should not throw or postpone here.\n  if (store.forceDynamic || store.forceStatic) return\n\n  if (store.dynamicShouldError) {\n    throw new StaticGenBailoutError(\n      `Route ${store.route} with \\`dynamic = \"error\"\\` couldn't be rendered statically because it used \\`${expression}\\`. See more info here: https://nextjs.org/docs/app/building-your-application/rendering/static-and-dynamic#dynamic-rendering`\n    )\n  }\n\n  if (workUnitStore) {\n    if (workUnitStore.type === 'prerender-ppr') {\n      postponeWithTracking(\n        store.route,\n        expression,\n        workUnitStore.dynamicTracking\n      )\n    } else if (workUnitStore.type === 'prerender-legacy') {\n      workUnitStore.revalidate = 0\n\n      // We aren't prerendering but we are generating a static page. We need to bail out of static generation\n      const err = new DynamicServerError(\n        `Route ${store.route} couldn't be rendered statically because it used ${expression}. See more info here: https://nextjs.org/docs/messages/dynamic-server-error`\n      )\n      store.dynamicUsageDescription = expression\n      store.dynamicUsageStack = err.stack\n\n      throw err\n    } else if (\n      process.env.NODE_ENV === 'development' &&\n      workUnitStore &&\n      workUnitStore.type === 'request'\n    ) {\n      workUnitStore.usedDynamic = true\n    }\n  }\n}\n\n/**\n * This function communicates that some dynamic path parameter was read. This\n * differs from the more general `trackDynamicDataAccessed` in that it is will\n * not error when `dynamic = \"error\"` is set.\n *\n * @param store The static generation store\n * @param expression The expression that was accessed dynamically\n */\nexport function trackFallbackParamAccessed(\n  store: WorkStore,\n  expression: string\n): void {\n  const prerenderStore = workUnitAsyncStorage.getStore()\n  if (!prerenderStore || prerenderStore.type !== 'prerender-ppr') return\n\n  postponeWithTracking(store.route, expression, prerenderStore.dynamicTracking)\n}\n\n/**\n * This function is meant to be used when prerendering without dynamicIO or PPR.\n * When called during a build it will cause Next.js to consider the route as dynamic.\n *\n * @internal\n */\nexport function throwToInterruptStaticGeneration(\n  expression: string,\n  store: WorkStore,\n  prerenderStore: PrerenderStoreLegacy\n): never {\n  // We aren't prerendering but we are generating a static page. We need to bail out of static generation\n  const err = new DynamicServerError(\n    `Route ${store.route} couldn't be rendered statically because it used \\`${expression}\\`. See more info here: https://nextjs.org/docs/messages/dynamic-server-error`\n  )\n\n  prerenderStore.revalidate = 0\n\n  store.dynamicUsageDescription = expression\n  store.dynamicUsageStack = err.stack\n\n  throw err\n}\n\n/**\n * This function should be used to track whether something dynamic happened even when\n * we are in a dynamic render. This is useful for Dev where all renders are dynamic but\n * we still track whether dynamic APIs were accessed for helpful messaging\n *\n * @internal\n */\nexport function trackDynamicDataInDynamicRender(\n  _store: WorkStore,\n  workUnitStore: void | WorkUnitStore\n) {\n  if (workUnitStore) {\n    if (\n      workUnitStore.type === 'cache' ||\n      workUnitStore.type === 'unstable-cache'\n    ) {\n      // inside cache scopes marking a scope as dynamic has no effect because the outer cache scope\n      // creates a cache boundary. This is subtly different from reading a dynamic data source which is\n      // forbidden inside a cache scope.\n      return\n    }\n    // TODO: it makes no sense to have these work unit store types during a dev render.\n    if (\n      workUnitStore.type === 'prerender' ||\n      workUnitStore.type === 'prerender-client' ||\n      workUnitStore.type === 'prerender-legacy'\n    ) {\n      workUnitStore.revalidate = 0\n    }\n    if (\n      process.env.NODE_ENV === 'development' &&\n      workUnitStore.type === 'request'\n    ) {\n      workUnitStore.usedDynamic = true\n    }\n  }\n}\n\nfunction abortOnSynchronousDynamicDataAccess(\n  route: string,\n  expression: string,\n  prerenderStore: PrerenderStoreModern\n): void {\n  const reason = `Route ${route} needs to bail out of prerendering at this point because it used ${expression}.`\n\n  const error = createPrerenderInterruptedError(reason)\n\n  prerenderStore.controller.abort(error)\n\n  const dynamicTracking = prerenderStore.dynamicTracking\n  if (dynamicTracking) {\n    dynamicTracking.dynamicAccesses.push({\n      // When we aren't debugging, we don't need to create another error for the\n      // stack trace.\n      stack: dynamicTracking.isDebugDynamicAccesses\n        ? new Error().stack\n        : undefined,\n      expression,\n    })\n  }\n}\n\nexport function abortOnSynchronousPlatformIOAccess(\n  route: string,\n  expression: string,\n  errorWithStack: Error,\n  prerenderStore: PrerenderStoreModern\n): void {\n  const dynamicTracking = prerenderStore.dynamicTracking\n  abortOnSynchronousDynamicDataAccess(route, expression, prerenderStore)\n  // It is important that we set this tracking value after aborting. Aborts are executed\n  // synchronously except for the case where you abort during render itself. By setting this\n  // value late we can use it to determine if any of the aborted tasks are the task that\n  // called the sync IO expression in the first place.\n  if (dynamicTracking) {\n    if (dynamicTracking.syncDynamicErrorWithStack === null) {\n      dynamicTracking.syncDynamicErrorWithStack = errorWithStack\n    }\n  }\n}\n\nexport function trackSynchronousPlatformIOAccessInDev(\n  requestStore: RequestStore\n): void {\n  // We don't actually have a controller to abort but we do the semantic equivalent by\n  // advancing the request store out of prerender mode\n  requestStore.prerenderPhase = false\n}\n\n/**\n * use this function when prerendering with dynamicIO. If we are doing a\n * prospective prerender we don't actually abort because we want to discover\n * all caches for the shell. If this is the actual prerender we do abort.\n *\n * This function accepts a prerenderStore but the caller should ensure we're\n * actually running in dynamicIO mode.\n *\n * @internal\n */\nexport function abortAndThrowOnSynchronousRequestDataAccess(\n  route: string,\n  expression: string,\n  errorWithStack: Error,\n  prerenderStore: PrerenderStoreModern\n): never {\n  const prerenderSignal = prerenderStore.controller.signal\n  if (prerenderSignal.aborted === false) {\n    // TODO it would be better to move this aborted check into the callsite so we can avoid making\n    // the error object when it isn't relevant to the aborting of the prerender however\n    // since we need the throw semantics regardless of whether we abort it is easier to land\n    // this way. See how this was handled with `abortOnSynchronousPlatformIOAccess` for a closer\n    // to ideal implementation\n    abortOnSynchronousDynamicDataAccess(route, expression, prerenderStore)\n    // It is important that we set this tracking value after aborting. Aborts are executed\n    // synchronously except for the case where you abort during render itself. By setting this\n    // value late we can use it to determine if any of the aborted tasks are the task that\n    // called the sync IO expression in the first place.\n    const dynamicTracking = prerenderStore.dynamicTracking\n    if (dynamicTracking) {\n      if (dynamicTracking.syncDynamicErrorWithStack === null) {\n        dynamicTracking.syncDynamicErrorWithStack = errorWithStack\n      }\n    }\n  }\n  throw createPrerenderInterruptedError(\n    `Route ${route} needs to bail out of prerendering at this point because it used ${expression}.`\n  )\n}\n\n// For now these implementations are the same so we just reexport\nexport const trackSynchronousRequestDataAccessInDev =\n  trackSynchronousPlatformIOAccessInDev\n\n/**\n * This component will call `React.postpone` that throws the postponed error.\n */\ntype PostponeProps = {\n  reason: string\n  route: string\n}\nexport function Postpone({ reason, route }: PostponeProps): never {\n  const prerenderStore = workUnitAsyncStorage.getStore()\n  const dynamicTracking =\n    prerenderStore && prerenderStore.type === 'prerender-ppr'\n      ? prerenderStore.dynamicTracking\n      : null\n  postponeWithTracking(route, reason, dynamicTracking)\n}\n\nexport function postponeWithTracking(\n  route: string,\n  expression: string,\n  dynamicTracking: null | DynamicTrackingState\n): never {\n  assertPostpone()\n  if (dynamicTracking) {\n    dynamicTracking.dynamicAccesses.push({\n      // When we aren't debugging, we don't need to create another error for the\n      // stack trace.\n      stack: dynamicTracking.isDebugDynamicAccesses\n        ? new Error().stack\n        : undefined,\n      expression,\n    })\n  }\n\n  React.unstable_postpone(createPostponeReason(route, expression))\n}\n\nfunction createPostponeReason(route: string, expression: string) {\n  return (\n    `Route ${route} needs to bail out of prerendering at this point because it used ${expression}. ` +\n    `React throws this special object to indicate where. It should not be caught by ` +\n    `your own try/catch. Learn more: https://nextjs.org/docs/messages/ppr-caught-error`\n  )\n}\n\nexport function isDynamicPostpone(err: unknown) {\n  if (\n    typeof err === 'object' &&\n    err !== null &&\n    typeof (err as any).message === 'string'\n  ) {\n    return isDynamicPostponeReason((err as any).message)\n  }\n  return false\n}\n\nfunction isDynamicPostponeReason(reason: string) {\n  return (\n    reason.includes(\n      'needs to bail out of prerendering at this point because it used'\n    ) &&\n    reason.includes(\n      'Learn more: https://nextjs.org/docs/messages/ppr-caught-error'\n    )\n  )\n}\n\nif (isDynamicPostponeReason(createPostponeReason('%%%', '^^^')) === false) {\n  throw new Error(\n    'Invariant: isDynamicPostpone misidentified a postpone reason. This is a bug in Next.js'\n  )\n}\n\nconst NEXT_PRERENDER_INTERRUPTED = 'NEXT_PRERENDER_INTERRUPTED'\n\nfunction createPrerenderInterruptedError(message: string): Error {\n  const error = new Error(message)\n  ;(error as any).digest = NEXT_PRERENDER_INTERRUPTED\n  return error\n}\n\ntype DigestError = Error & {\n  digest: string\n}\n\nexport function isPrerenderInterruptedError(\n  error: unknown\n): error is DigestError {\n  return (\n    typeof error === 'object' &&\n    error !== null &&\n    (error as any).digest === NEXT_PRERENDER_INTERRUPTED &&\n    'name' in error &&\n    'message' in error &&\n    error instanceof Error\n  )\n}\n\nexport function accessedDynamicData(\n  dynamicAccesses: Array<DynamicAccess>\n): boolean {\n  return dynamicAccesses.length > 0\n}\n\nexport function consumeDynamicAccess(\n  serverDynamic: DynamicTrackingState,\n  clientDynamic: DynamicTrackingState\n): DynamicTrackingState['dynamicAccesses'] {\n  // We mutate because we only call this once we are no longer writing\n  // to the dynamicTrackingState and it's more efficient than creating a new\n  // array.\n  serverDynamic.dynamicAccesses.push(...clientDynamic.dynamicAccesses)\n  return serverDynamic.dynamicAccesses\n}\n\nexport function formatDynamicAPIAccesses(\n  dynamicAccesses: Array<DynamicAccess>\n): string[] {\n  return dynamicAccesses\n    .filter(\n      (access): access is Required<DynamicAccess> =>\n        typeof access.stack === 'string' && access.stack.length > 0\n    )\n    .map(({ expression, stack }) => {\n      stack = stack\n        .split('\\n')\n        // Remove the \"Error: \" prefix from the first line of the stack trace as\n        // well as the first 4 lines of the stack trace which is the distance\n        // from the user code and the `new Error().stack` call.\n        .slice(4)\n        .filter((line) => {\n          // Exclude Next.js internals from the stack trace.\n          if (line.includes('node_modules/next/')) {\n            return false\n          }\n\n          // Exclude anonymous functions from the stack trace.\n          if (line.includes(' (<anonymous>)')) {\n            return false\n          }\n\n          // Exclude Node.js internals from the stack trace.\n          if (line.includes(' (node:')) {\n            return false\n          }\n\n          return true\n        })\n        .join('\\n')\n      return `Dynamic API Usage Debug - ${expression}:\\n${stack}`\n    })\n}\n\nfunction assertPostpone() {\n  if (!hasPostpone) {\n    throw new Error(\n      `Invariant: React.unstable_postpone is not defined. This suggests the wrong version of React was loaded. This is a bug in Next.js`\n    )\n  }\n}\n\n/**\n * This is a bit of a hack to allow us to abort a render using a Postpone instance instead of an Error which changes React's\n * abort semantics slightly.\n */\nexport function createPostponedAbortSignal(reason: string): AbortSignal {\n  assertPostpone()\n  const controller = new AbortController()\n  // We get our hands on a postpone instance by calling postpone and catching the throw\n  try {\n    React.unstable_postpone(reason)\n  } catch (x: unknown) {\n    controller.abort(x)\n  }\n  return controller.signal\n}\n\n/**\n * In a prerender, we may end up with hanging Promises as inputs due them\n * stalling on connection() or because they're loading dynamic data. In that\n * case we need to abort the encoding of arguments since they'll never complete.\n */\nexport function createHangingInputAbortSignal(\n  workUnitStore: PrerenderStoreModern\n): AbortSignal {\n  const controller = new AbortController()\n\n  if (workUnitStore.cacheSignal) {\n    // If we have a cacheSignal it means we're in a prospective render. If the input\n    // we're waiting on is coming from another cache, we do want to wait for it so that\n    // we can resolve this cache entry too.\n    workUnitStore.cacheSignal.inputReady().then(() => {\n      controller.abort()\n    })\n  } else {\n    // Otherwise we're in the final render and we should already have all our caches\n    // filled. We might still be waiting on some microtasks so we wait one tick before\n    // giving up. When we give up, we still want to render the content of this cache\n    // as deeply as we can so that we can suspend as deeply as possible in the tree\n    // or not at all if we don't end up waiting for the input.\n    scheduleOnNextTick(() => controller.abort())\n  }\n\n  return controller.signal\n}\n\nexport function annotateDynamicAccess(\n  expression: string,\n  prerenderStore: PrerenderStoreModern\n) {\n  const dynamicTracking = prerenderStore.dynamicTracking\n  if (dynamicTracking) {\n    dynamicTracking.dynamicAccesses.push({\n      stack: dynamicTracking.isDebugDynamicAccesses\n        ? new Error().stack\n        : undefined,\n      expression,\n    })\n  }\n}\n\nexport function useDynamicRouteParams(expression: string) {\n  const workStore = workAsyncStorage.getStore()\n\n  if (\n    workStore &&\n    workStore.isStaticGeneration &&\n    workStore.fallbackRouteParams &&\n    workStore.fallbackRouteParams.size > 0\n  ) {\n    // There are fallback route params, we should track these as dynamic\n    // accesses.\n    const workUnitStore = workUnitAsyncStorage.getStore()\n    if (workUnitStore) {\n      // We're prerendering with dynamicIO or PPR or both\n      if (workUnitStore.type === 'prerender-client') {\n        // We are in a prerender with dynamicIO semantics\n        // We are going to hang here and never resolve. This will cause the currently\n        // rendering component to effectively be a dynamic hole\n        React.use(makeHangingPromise(workUnitStore.renderSignal, expression))\n      } else if (workUnitStore.type === 'prerender-ppr') {\n        // We're prerendering with PPR\n        postponeWithTracking(\n          workStore.route,\n          expression,\n          workUnitStore.dynamicTracking\n        )\n      } else if (workUnitStore.type === 'prerender-legacy') {\n        throwToInterruptStaticGeneration(expression, workStore, workUnitStore)\n      }\n    }\n  }\n}\n\nconst hasSuspenseRegex = /\\n\\s+at Suspense \\(<anonymous>\\)/\nconst hasSuspenseAfterBodyOrHtmlRegex =\n  /\\n\\s+at (?:body|html) \\(<anonymous>\\)[\\s\\S]*?\\n\\s+at Suspense \\(<anonymous>\\)/\nconst hasMetadataRegex = new RegExp(\n  `\\\\n\\\\s+at ${METADATA_BOUNDARY_NAME}[\\\\n\\\\s]`\n)\nconst hasViewportRegex = new RegExp(\n  `\\\\n\\\\s+at ${VIEWPORT_BOUNDARY_NAME}[\\\\n\\\\s]`\n)\nconst hasOutletRegex = new RegExp(`\\\\n\\\\s+at ${OUTLET_BOUNDARY_NAME}[\\\\n\\\\s]`)\n\nexport function trackAllowedDynamicAccess(\n  workStore: WorkStore,\n  componentStack: string,\n  dynamicValidation: DynamicValidationState,\n  clientDynamic: DynamicTrackingState\n) {\n  if (hasOutletRegex.test(componentStack)) {\n    // We don't need to track that this is dynamic. It is only so when something else is also dynamic.\n    return\n  } else if (hasMetadataRegex.test(componentStack)) {\n    dynamicValidation.hasDynamicMetadata = true\n    return\n  } else if (hasViewportRegex.test(componentStack)) {\n    dynamicValidation.hasDynamicViewport = true\n    return\n  } else if (hasSuspenseAfterBodyOrHtmlRegex.test(componentStack)) {\n    // This prerender has a Suspense boundary above the body which\n    // effectively opts the page into allowing 100% dynamic rendering\n    dynamicValidation.hasAllowedDynamic = true\n    dynamicValidation.hasSuspenseAboveBody = true\n    return\n  } else if (hasSuspenseRegex.test(componentStack)) {\n    // this error had a Suspense boundary above it so we don't need to report it as a source\n    // of disallowed\n    dynamicValidation.hasAllowedDynamic = true\n    return\n  } else if (clientDynamic.syncDynamicErrorWithStack) {\n    // This task was the task that called the sync error.\n    dynamicValidation.dynamicErrors.push(\n      clientDynamic.syncDynamicErrorWithStack\n    )\n    return\n  } else {\n    const message = `Route \"${workStore.route}\": A component accessed data, headers, params, searchParams, or a short-lived cache without a Suspense boundary nor a \"use cache\" above it. See more info: https://nextjs.org/docs/messages/next-prerender-missing-suspense`\n    const error = createErrorWithComponentOrOwnerStack(message, componentStack)\n    dynamicValidation.dynamicErrors.push(error)\n    return\n  }\n}\n\n/**\n * In dev mode, we prefer using the owner stack, otherwise the provided\n * component stack is used.\n */\nfunction createErrorWithComponentOrOwnerStack(\n  message: string,\n  componentStack: string\n) {\n  const ownerStack =\n    process.env.NODE_ENV !== 'production' && React.captureOwnerStack\n      ? React.captureOwnerStack()\n      : null\n\n  const error = new Error(message)\n  error.stack = error.name + ': ' + message + (ownerStack ?? componentStack)\n  return error\n}\n\nexport enum PreludeState {\n  Full = 0,\n  Empty = 1,\n  Errored = 2,\n}\n\nfunction logDisallowedDynamicError(workStore: WorkStore, error: Error): void {\n  console.error(error)\n\n  if (!workStore.dev) {\n    if (workStore.hasReadableErrorStacks) {\n      console.error(\n        `To get a more detailed stack trace and pinpoint the issue, start the app in development mode by running \\`next dev\\`, then open \"${workStore.route}\" in your browser to investigate the error.`\n      )\n    } else {\n      console.error(`To get a more detailed stack trace and pinpoint the issue, try one of the following:\n  - Start the app in development mode by running \\`next dev\\`, then open \"${workStore.route}\" in your browser to investigate the error.\n  - Rerun the production build with \\`next build --debug-prerender\\` to generate better stack traces.`)\n    }\n  }\n}\n\nexport function throwIfDisallowedDynamic(\n  workStore: WorkStore,\n  prelude: PreludeState,\n  dynamicValidation: DynamicValidationState,\n  serverDynamic: DynamicTrackingState\n): void {\n  if (workStore.invalidDynamicUsageError) {\n    logDisallowedDynamicError(workStore, workStore.invalidDynamicUsageError)\n    throw new StaticGenBailoutError()\n  }\n\n  if (prelude !== PreludeState.Full) {\n    if (dynamicValidation.hasSuspenseAboveBody) {\n      // This route has opted into allowing fully dynamic rendering\n      // by including a Suspense boundary above the body. In this case\n      // a lack of a shell is not considered disallowed so we simply return\n      return\n    }\n\n    if (serverDynamic.syncDynamicErrorWithStack) {\n      // There is no shell and the server did something sync dynamic likely\n      // leading to an early termination of the prerender before the shell\n      // could be completed. We terminate the build/validating render.\n      logDisallowedDynamicError(\n        workStore,\n        serverDynamic.syncDynamicErrorWithStack\n      )\n      throw new StaticGenBailoutError()\n    }\n\n    // We didn't have any sync bailouts but there may be user code which\n    // blocked the root. We would have captured these during the prerender\n    // and can log them here and then terminate the build/validating render\n    const dynamicErrors = dynamicValidation.dynamicErrors\n    if (dynamicErrors.length > 0) {\n      for (let i = 0; i < dynamicErrors.length; i++) {\n        logDisallowedDynamicError(workStore, dynamicErrors[i])\n      }\n\n      throw new StaticGenBailoutError()\n    }\n\n    // If we got this far then the only other thing that could be blocking\n    // the root is dynamic Viewport. If this is dynamic then\n    // you need to opt into that by adding a Suspense boundary above the body\n    // to indicate your are ok with fully dynamic rendering.\n    if (dynamicValidation.hasDynamicViewport) {\n      console.error(\n        `Route \"${workStore.route}\" has a \\`generateViewport\\` that depends on Request data (\\`cookies()\\`, etc...) or uncached external data (\\`fetch(...)\\`, etc...) without explicitly allowing fully dynamic rendering. See more info here: https://nextjs.org/docs/messages/next-prerender-dynamic-viewport`\n      )\n      throw new StaticGenBailoutError()\n    }\n\n    if (prelude === PreludeState.Empty) {\n      // If we ever get this far then we messed up the tracking of invalid dynamic.\n      // We still adhere to the constraint that you must produce a shell but invite the\n      // user to report this as a bug in Next.js.\n      console.error(\n        `Route \"${workStore.route}\" did not produce a static shell and Next.js was unable to determine a reason. This is a bug in Next.js.`\n      )\n      throw new StaticGenBailoutError()\n    }\n  } else {\n    if (\n      dynamicValidation.hasAllowedDynamic === false &&\n      dynamicValidation.hasDynamicMetadata\n    ) {\n      console.error(\n        `Route \"${workStore.route}\" has a \\`generateMetadata\\` that depends on Request data (\\`cookies()\\`, etc...) or uncached external data (\\`fetch(...)\\`, etc...) when the rest of the route does not. See more info here: https://nextjs.org/docs/messages/next-prerender-dynamic-metadata`\n      )\n      throw new StaticGenBailoutError()\n    }\n  }\n}\n"],"names":["Postpone","PreludeState","abortAndThrowOnSynchronousRequestDataAccess","abortOnSynchronousPlatformIOAccess","accessedDynamicData","annotateDynamicAccess","consumeDynamicAccess","createDynamicTrackingState","createDynamicValidationState","createHangingInputAbortSignal","createPostponedAbortSignal","formatDynamicAPIAccesses","getFirstDynamicReason","isDynamicPostpone","isPrerenderInterruptedError","markCurrentScopeAsDynamic","postponeWithTracking","throwIfDisallowedDynamic","throwToInterruptStaticGeneration","trackAllowedDynamicAccess","trackDynamicDataInDynamicRender","trackFallbackParamAccessed","trackSynchronousPlatformIOAccessInDev","trackSynchronousRequestDataAccessInDev","useDynamicRouteParams","hasPostpone","React","unstable_postpone","isDebugDynamicAccesses","dynamicAccesses","syncDynamicErrorWithStack","hasSuspenseAboveBody","hasDynamicMetadata","hasDynamicViewport","hasAllowedDynamic","dynamicErrors","trackingState","expression","store","workUnitStore","type","forceDynamic","forceStatic","dynamicShouldError","StaticGenBailoutError","route","dynamicTracking","revalidate","err","DynamicServerError","dynamicUsageDescription","dynamicUsageStack","stack","process","env","NODE_ENV","usedDynamic","prerenderStore","workUnitAsyncStorage","getStore","_store","abortOnSynchronousDynamicDataAccess","reason","error","createPrerenderInterruptedError","controller","abort","push","Error","undefined","errorWithStack","requestStore","prerenderPhase","prerenderSignal","signal","aborted","assertPostpone","createPostponeReason","message","isDynamicPostponeReason","includes","NEXT_PRERENDER_INTERRUPTED","digest","length","serverDynamic","clientDynamic","filter","access","map","split","slice","line","join","AbortController","x","cacheSignal","inputReady","then","scheduleOnNextTick","workStore","workAsyncStorage","isStaticGeneration","fallbackRouteParams","size","use","makeHangingPromise","renderSignal","hasSuspenseRegex","hasSuspenseAfterBodyOrHtmlRegex","hasMetadataRegex","RegExp","METADATA_BOUNDARY_NAME","hasViewportRegex","VIEWPORT_BOUNDARY_NAME","hasOutletRegex","OUTLET_BOUNDARY_NAME","componentStack","dynamicValidation","test","createErrorWithComponentOrOwnerStack","ownerStack","captureOwnerStack","name","logDisallowedDynamicError","console","dev","hasReadableErrorStacks","prelude","invalidDynamicUsageError","i"],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 1321, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/lenovo/Desktop/LinkdinClone/frontend/node_modules/next/src/server/create-deduped-by-callsite-server-error-logger.ts"],"sourcesContent":["import * as React from 'react'\n\nconst errorRef: { current: null | Error } = { current: null }\n\n// React.cache is currently only available in canary/experimental React channels.\nconst cache =\n  typeof React.cache === 'function'\n    ? React.cache\n    : (fn: (key: unknown) => void) => fn\n\n// When Dynamic IO is enabled, we record these as errors so that they\n// are captured by the dev overlay as it's more critical to fix these\n// when enabled.\nconst logErrorOrWarn = process.env.__NEXT_DYNAMIC_IO\n  ? console.error\n  : console.warn\n\n// We don't want to dedupe across requests.\n// The developer might've just attempted to fix the warning so we should warn again if it still happens.\nconst flushCurrentErrorIfNew = cache(\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars -- cache key\n  (key: unknown) => {\n    try {\n      logErrorOrWarn(errorRef.current)\n    } finally {\n      errorRef.current = null\n    }\n  }\n)\n\n/**\n * Creates a function that logs an error message that is deduped by the userland\n * callsite.\n * This requires no indirection between the call of this function and the userland\n * callsite i.e. there's only a single library frame above this.\n * Do not use on the Client where sourcemaps and ignore listing might be enabled.\n * Only use that for warnings need a fix independent of the callstack.\n *\n * @param getMessage\n * @returns\n */\nexport function createDedupedByCallsiteServerErrorLoggerDev<Args extends any[]>(\n  getMessage: (...args: Args) => Error\n) {\n  return function logDedupedError(...args: Args) {\n    const message = getMessage(...args)\n\n    if (process.env.NODE_ENV !== 'production') {\n      const callStackFrames = new Error().stack?.split('\\n')\n      if (callStackFrames === undefined || callStackFrames.length < 4) {\n        logErrorOrWarn(message)\n      } else {\n        // Error:\n        //   logDedupedError\n        //   asyncApiBeingAccessedSynchronously\n        //   <userland callsite>\n        // TODO: This breaks if sourcemaps with ignore lists are enabled.\n        const key = callStackFrames[4]\n        errorRef.current = message\n        flushCurrentErrorIfNew(key)\n      }\n    } else {\n      logErrorOrWarn(message)\n    }\n  }\n}\n"],"names":["createDedupedByCallsiteServerErrorLoggerDev","errorRef","current","cache","React","fn","logErrorOrWarn","process","env","__NEXT_DYNAMIC_IO","console","error","warn","flushCurrentErrorIfNew","key","getMessage","logDedupedError","args","message","NODE_ENV","callStackFrames","Error","stack","split","undefined","length"],"mappings":"AAauBO,QAAQC,GAAG,CAACC,iBAAiB;;;;;+BA4BpCT,+CAAAA;;;eAAAA;;;+DAzCO;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAEvB,MAAMC,WAAsC;IAAEC,SAAS;AAAK;AAE5D,iFAAiF;AACjF,MAAMC,QACJ,OAAOC,OAAMD,KAAK,KAAK,aACnBC,OAAMD,KAAK,GACX,CAACE,KAA+BA;AAEtC,qEAAqE;AACrE,qEAAqE;AACrE,gBAAgB;AAChB,MAAMC,uDACFI,QAAQC,KAAK,aACbD,QAAQE,IAAI;AAEhB,2CAA2C;AAC3C,wGAAwG;AACxG,MAAMC,yBAAyBV,MAC7B,AACA,CAACW,yEADyE;IAExE,IAAI;QACFR,eAAeL,SAASC,OAAO;IACjC,SAAU;QACRD,SAASC,OAAO,GAAG;IACrB;AACF;AAcK,SAASF,4CACde,UAAoC;IAEpC,OAAO,SAASC;;YAAmBC,uBAAH,KAAa;;QAC3C,MAAMC,UAAUH,cAAcE;QAE9B,IAAIV,QAAQC,GAAG,CAACW,QAAQ,KAAK,WAAc;gBACjB;YAAxB,MAAMC,kBAAAA,CAAkB,SAAA,IAAIC,QAAQC,KAAK,KAAA,OAAA,KAAA,IAAjB,OAAmBC,KAAK,CAAC;YACjD,IAAIH,oBAAoBI,aAAaJ,gBAAgBK,MAAM,GAAG,GAAG;gBAC/DnB,eAAeY;YACjB,OAAO;gBACL,SAAS;gBACT,oBAAoB;gBACpB,uCAAuC;gBACvC,wBAAwB;gBACxB,iEAAiE;gBACjE,MAAMJ,MAAMM,eAAe,CAAC,EAAE;gBAC9BnB,SAASC,OAAO,GAAGgB;gBACnBL,uBAAuBC;YACzB;QACF,OAAO;;IAGT;AACF","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 1423, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/lenovo/Desktop/LinkdinClone/frontend/node_modules/next/src/server/app-render/after-task-async-storage-instance.ts"],"sourcesContent":["import type { AfterTaskAsyncStorage } from './after-task-async-storage.external'\nimport { createAsyncLocalStorage } from './async-local-storage'\n\nexport const afterTaskAsyncStorageInstance: AfterTaskAsyncStorage =\n  createAsyncLocalStorage()\n"],"names":["afterTaskAsyncStorageInstance","createAsyncLocalStorage"],"mappings":";;;+BAGaA,iCAAAA;;;eAAAA;;;mCAF2B;AAEjC,MAAMA,gCACXC,CAAAA,GAAAA,mBAAAA,uBAAuB","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 1440, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/lenovo/Desktop/LinkdinClone/frontend/node_modules/next/src/server/app-render/after-task-async-storage.external.ts"],"sourcesContent":["import type { AsyncLocalStorage } from 'async_hooks'\n\n// Share the instance module in the next-shared layer\nimport { afterTaskAsyncStorageInstance as afterTaskAsyncStorage } from './after-task-async-storage-instance' with { 'turbopack-transition': 'next-shared' }\nimport type { WorkUnitStore } from './work-unit-async-storage.external'\n\nexport interface AfterTaskStore {\n  /** The phase in which the topmost `after` was called.\n   *\n   * NOTE: Can be undefined when running `generateStaticParams`,\n   * where we only have a `workStore`, no `workUnitStore`.\n   */\n  readonly rootTaskSpawnPhase: WorkUnitStore['phase'] | undefined\n}\n\nexport type AfterTaskAsyncStorage = AsyncLocalStorage<AfterTaskStore>\n\nexport { afterTaskAsyncStorage }\n"],"names":["afterTaskAsyncStorage"],"mappings":";;;+BAiBSA,yBAAAA;;;eAAAA,+BAAAA,6BAAqB;;;+CAdyC","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 1456, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/lenovo/Desktop/LinkdinClone/frontend/node_modules/next/src/server/request/utils.ts"],"sourcesContent":["import { StaticGenBailoutError } from '../../client/components/static-generation-bailout'\nimport { afterTaskAsyncStorage } from '../app-render/after-task-async-storage.external'\nimport type { WorkStore } from '../app-render/work-async-storage.external'\n\nexport function throwWithStaticGenerationBailoutError(\n  route: string,\n  expression: string\n): never {\n  throw new StaticGenBailoutError(\n    `Route ${route} couldn't be rendered statically because it used ${expression}. See more info here: https://nextjs.org/docs/app/building-your-application/rendering/static-and-dynamic#dynamic-rendering`\n  )\n}\n\nexport function throwWithStaticGenerationBailoutErrorWithDynamicError(\n  route: string,\n  expression: string\n): never {\n  throw new StaticGenBailoutError(\n    `Route ${route} with \\`dynamic = \"error\"\\` couldn't be rendered statically because it used ${expression}. See more info here: https://nextjs.org/docs/app/building-your-application/rendering/static-and-dynamic#dynamic-rendering`\n  )\n}\n\nexport function throwForSearchParamsAccessInUseCache(\n  workStore: WorkStore,\n  constructorOpt: Function\n): never {\n  const error = new Error(\n    `Route ${workStore.route} used \"searchParams\" inside \"use cache\". Accessing Dynamic data sources inside a cache scope is not supported. If you need this data inside a cached function use \"searchParams\" outside of the cached function and pass the required dynamic data in as an argument. See more info here: https://nextjs.org/docs/messages/next-request-in-use-cache`\n  )\n\n  Error.captureStackTrace(error, constructorOpt)\n  workStore.invalidDynamicUsageError ??= error\n\n  throw error\n}\n\nexport function isRequestAPICallableInsideAfter() {\n  const afterTaskStore = afterTaskAsyncStorage.getStore()\n  return afterTaskStore?.rootTaskSpawnPhase === 'action'\n}\n"],"names":["isRequestAPICallableInsideAfter","throwForSearchParamsAccessInUseCache","throwWithStaticGenerationBailoutError","throwWithStaticGenerationBailoutErrorWithDynamicError","route","expression","StaticGenBailoutError","workStore","constructorOpt","error","Error","captureStackTrace","invalidDynamicUsageError","afterTaskStore","afterTaskAsyncStorage","getStore","rootTaskSpawnPhase"],"mappings":";;;;;;;;;;;;;;;;IAoCgBA,+BAA+B,EAAA;eAA/BA;;IAdAC,oCAAoC,EAAA;eAApCA;;IAlBAC,qCAAqC,EAAA;eAArCA;;IASAC,qDAAqD,EAAA;eAArDA;;;yCAbsB;+CACA;AAG/B,SAASD,sCACdE,KAAa,EACbC,UAAkB;IAElB,MAAM,OAAA,cAEL,CAFK,IAAIC,yBAAAA,qBAAqB,CAC7B,AAAC,MAAM,UAAEF,OAAM,iDAAiD,WAAEC,YAAW,0HAA0H,CAAC,KADpM,qBAAA;eAAA;oBAAA;sBAAA;IAEN;AACF;AAEO,SAASF,sDACdC,KAAa,EACbC,UAAkB;IAElB,MAAM,OAAA,cAEL,CAFK,IAAIC,yBAAAA,qBAAqB,CAC7B,AAAC,MAAM,UAAEF,OAAM,4EAA4E,UAAEC,YAAW,0HAA0H,CAAC,KAD/N,qBAAA;eAAA;oBAAA;sBAAA;IAEN;AACF;AAEO,SAASJ,qCACdM,SAAoB,EACpBC,cAAwB;QAOxBD;IALA,MAAME,QAAQ,OAAA,cAEb,CAFa,IAAIC,MAChB,AAAC,MAAM,UAAEH,UAAUH,KAAK,EAAC,oVAAoV,CAAC,KADlW,qBAAA;eAAA;oBAAA;sBAAA;IAEd;IAEAM,MAAMC,iBAAiB,CAACF,OAAOD;;8KACrBI,wBAAwB,GAAKH;IAEvC,MAAMA;AACR;AAEO,SAAST;IACd,MAAMa,iBAAiBC,+BAAAA,qBAAqB,CAACC,QAAQ;IACrD,OAAOF,CAAAA,kBAAAA,OAAAA,KAAAA,IAAAA,eAAgBG,kBAAkB,MAAK;AAChD","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 1523, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/lenovo/Desktop/LinkdinClone/frontend/node_modules/next/src/server/request/cookies.ts"],"sourcesContent":["import {\n  type ReadonlyRequestCookies,\n  type ResponseCookies,\n  areCookiesMutableInCurrentPhase,\n  RequestCookiesAdapter,\n} from '../web/spec-extension/adapters/request-cookies'\nimport { RequestCookies } from '../web/spec-extension/cookies'\nimport { workAsyncStorage } from '../app-render/work-async-storage.external'\nimport {\n  workUnitAsyncStorage,\n  type PrerenderStoreModern,\n} from '../app-render/work-unit-async-storage.external'\nimport {\n  postponeWithTracking,\n  throwToInterruptStaticGeneration,\n  trackDynamicDataInDynamicRender,\n  trackSynchronousRequestDataAccessInDev,\n} from '../app-render/dynamic-rendering'\nimport { getExpectedRequestStore } from '../app-render/work-unit-async-storage.external'\nimport { StaticGenBailoutError } from '../../client/components/static-generation-bailout'\nimport { makeHangingPromise } from '../dynamic-rendering-utils'\nimport { createDedupedByCallsiteServerErrorLoggerDev } from '../create-deduped-by-callsite-server-error-logger'\nimport { scheduleImmediate } from '../../lib/scheduler'\nimport { isRequestAPICallableInsideAfter } from './utils'\nimport { InvariantError } from '../../shared/lib/invariant-error'\nimport { ReflectAdapter } from '../web/spec-extension/adapters/reflect'\n\n/**\n * In this version of Next.js `cookies()` returns a Promise however you can still reference the properties of the underlying cookies object\n * synchronously to facilitate migration. The `UnsafeUnwrappedCookies` type is added to your code by a codemod that attempts to automatically\n * updates callsites to reflect the new Promise return type. There are some cases where `cookies()` cannot be automatically converted, namely\n * when it is used inside a synchronous function and we can't be sure the function can be made async automatically. In these cases we add an\n * explicit type case to `UnsafeUnwrappedCookies` to enable typescript to allow for the synchronous usage only where it is actually necessary.\n *\n * You should should update these callsites to either be async functions where the `cookies()` value can be awaited or you should call `cookies()`\n * from outside and await the return value before passing it into this function.\n *\n * You can find instances that require manual migration by searching for `UnsafeUnwrappedCookies` in your codebase or by search for a comment that\n * starts with `@next-codemod-error`.\n *\n * In a future version of Next.js `cookies()` will only return a Promise and you will not be able to access the underlying cookies object directly\n * without awaiting the return value first. When this change happens the type `UnsafeUnwrappedCookies` will be updated to reflect that is it no longer\n * usable.\n *\n * This type is marked deprecated to help identify it as target for refactoring away.\n *\n * @deprecated\n */\nexport type UnsafeUnwrappedCookies = ReadonlyRequestCookies\n\nexport function cookies(): Promise<ReadonlyRequestCookies> {\n  const callingExpression = 'cookies'\n  const workStore = workAsyncStorage.getStore()\n  const workUnitStore = workUnitAsyncStorage.getStore()\n\n  if (workStore) {\n    if (\n      workUnitStore &&\n      workUnitStore.phase === 'after' &&\n      !isRequestAPICallableInsideAfter()\n    ) {\n      throw new Error(\n        // TODO(after): clarify that this only applies to pages?\n        `Route ${workStore.route} used \"cookies\" inside \"after(...)\". This is not supported. If you need this data inside an \"after\" callback, use \"cookies\" outside of the callback. See more info here: https://nextjs.org/docs/canary/app/api-reference/functions/after`\n      )\n    }\n\n    if (workStore.forceStatic) {\n      // When using forceStatic we override all other logic and always just return an empty\n      // cookies object without tracking\n      const underlyingCookies = createEmptyCookies()\n      return makeUntrackedExoticCookies(underlyingCookies)\n    }\n\n    if (workUnitStore) {\n      if (workUnitStore.type === 'cache') {\n        throw new Error(\n          `Route ${workStore.route} used \"cookies\" inside \"use cache\". Accessing Dynamic data sources inside a cache scope is not supported. If you need this data inside a cached function use \"cookies\" outside of the cached function and pass the required dynamic data in as an argument. See more info here: https://nextjs.org/docs/messages/next-request-in-use-cache`\n        )\n      } else if (workUnitStore.type === 'unstable-cache') {\n        throw new Error(\n          `Route ${workStore.route} used \"cookies\" inside a function cached with \"unstable_cache(...)\". Accessing Dynamic data sources inside a cache scope is not supported. If you need this data inside a cached function use \"cookies\" outside of the cached function and pass the required dynamic data in as an argument. See more info here: https://nextjs.org/docs/app/api-reference/functions/unstable_cache`\n        )\n      }\n    }\n    if (workStore.dynamicShouldError) {\n      throw new StaticGenBailoutError(\n        `Route ${workStore.route} with \\`dynamic = \"error\"\\` couldn't be rendered statically because it used \\`cookies\\`. See more info here: https://nextjs.org/docs/app/building-your-application/rendering/static-and-dynamic#dynamic-rendering`\n      )\n    }\n\n    if (workUnitStore) {\n      switch (workUnitStore.type) {\n        case 'prerender':\n          return makeHangingCookies(workUnitStore)\n        case 'prerender-client':\n          const exportName = '`cookies`'\n          throw new InvariantError(\n            `${exportName} must not be used within a client component. Next.js should be preventing ${exportName} from being included in client components statically, but did not in this case.`\n          )\n        case 'prerender-ppr':\n          // PPR Prerender (no dynamicIO)\n          // We are prerendering with PPR. We need track dynamic access here eagerly\n          // to keep continuity with how cookies has worked in PPR without dynamicIO.\n          postponeWithTracking(\n            workStore.route,\n            callingExpression,\n            workUnitStore.dynamicTracking\n          )\n          break\n        case 'prerender-legacy':\n          // Legacy Prerender\n          // We track dynamic access here so we don't need to wrap the cookies in\n          // individual property access tracking.\n          throwToInterruptStaticGeneration(\n            callingExpression,\n            workStore,\n            workUnitStore\n          )\n          break\n        default:\n        // fallthrough\n      }\n    }\n    // We fall through to the dynamic context below but we still track dynamic access\n    // because in dev we can still error for things like using cookies inside a cache context\n    trackDynamicDataInDynamicRender(workStore, workUnitStore)\n  }\n\n  // cookies is being called in a dynamic context\n\n  const requestStore = getExpectedRequestStore(callingExpression)\n\n  let underlyingCookies: ReadonlyRequestCookies\n\n  if (areCookiesMutableInCurrentPhase(requestStore)) {\n    // We can't conditionally return different types here based on the context.\n    // To avoid confusion, we always return the readonly type here.\n    underlyingCookies =\n      requestStore.userspaceMutableCookies as unknown as ReadonlyRequestCookies\n  } else {\n    underlyingCookies = requestStore.cookies\n  }\n\n  if (process.env.NODE_ENV === 'development' && !workStore?.isPrefetchRequest) {\n    if (process.env.__NEXT_DYNAMIC_IO) {\n      return makeUntrackedCookiesWithDevWarnings(\n        underlyingCookies,\n        workStore?.route\n      )\n    }\n\n    return makeUntrackedExoticCookiesWithDevWarnings(\n      underlyingCookies,\n      workStore?.route\n    )\n  } else {\n    return makeUntrackedExoticCookies(underlyingCookies)\n  }\n}\n\nfunction createEmptyCookies(): ReadonlyRequestCookies {\n  return RequestCookiesAdapter.seal(new RequestCookies(new Headers({})))\n}\n\ninterface CacheLifetime {}\nconst CachedCookies = new WeakMap<\n  CacheLifetime,\n  Promise<ReadonlyRequestCookies>\n>()\n\nfunction makeHangingCookies(\n  prerenderStore: PrerenderStoreModern\n): Promise<ReadonlyRequestCookies> {\n  const cachedPromise = CachedCookies.get(prerenderStore)\n  if (cachedPromise) {\n    return cachedPromise\n  }\n\n  const promise = makeHangingPromise<ReadonlyRequestCookies>(\n    prerenderStore.renderSignal,\n    '`cookies()`'\n  )\n  CachedCookies.set(prerenderStore, promise)\n\n  return promise\n}\n\nfunction makeUntrackedExoticCookies(\n  underlyingCookies: ReadonlyRequestCookies\n): Promise<ReadonlyRequestCookies> {\n  const cachedCookies = CachedCookies.get(underlyingCookies)\n  if (cachedCookies) {\n    return cachedCookies\n  }\n\n  const promise = Promise.resolve(underlyingCookies)\n  CachedCookies.set(underlyingCookies, promise)\n\n  Object.defineProperties(promise, {\n    [Symbol.iterator]: {\n      value: underlyingCookies[Symbol.iterator]\n        ? underlyingCookies[Symbol.iterator].bind(underlyingCookies)\n        : // TODO this is a polyfill for when the underlying type is ResponseCookies\n          // We should remove this and unify our cookies types. We could just let this continue to throw lazily\n          // but that's already a hard thing to debug so we may as well implement it consistently. The biggest problem with\n          // implementing this in this way is the underlying cookie type is a ResponseCookie and not a RequestCookie and so it\n          // has extra properties not available on RequestCookie instances.\n          polyfilledResponseCookiesIterator.bind(underlyingCookies),\n    },\n    size: {\n      get(): number {\n        return underlyingCookies.size\n      },\n    },\n    get: {\n      value: underlyingCookies.get.bind(underlyingCookies),\n    },\n    getAll: {\n      value: underlyingCookies.getAll.bind(underlyingCookies),\n    },\n    has: {\n      value: underlyingCookies.has.bind(underlyingCookies),\n    },\n    set: {\n      value: underlyingCookies.set.bind(underlyingCookies),\n    },\n    delete: {\n      value: underlyingCookies.delete.bind(underlyingCookies),\n    },\n    clear: {\n      value:\n        // @ts-expect-error clear is defined in RequestCookies implementation but not in the type\n        typeof underlyingCookies.clear === 'function'\n          ? // @ts-expect-error clear is defined in RequestCookies implementation but not in the type\n            underlyingCookies.clear.bind(underlyingCookies)\n          : // TODO this is a polyfill for when the underlying type is ResponseCookies\n            // We should remove this and unify our cookies types. We could just let this continue to throw lazily\n            // but that's already a hard thing to debug so we may as well implement it consistently. The biggest problem with\n            // implementing this in this way is the underlying cookie type is a ResponseCookie and not a RequestCookie and so it\n            // has extra properties not available on RequestCookie instances.\n            polyfilledResponseCookiesClear.bind(underlyingCookies, promise),\n    },\n    toString: {\n      value: underlyingCookies.toString.bind(underlyingCookies),\n    },\n  } satisfies CookieExtensions)\n\n  return promise\n}\n\nfunction makeUntrackedExoticCookiesWithDevWarnings(\n  underlyingCookies: ReadonlyRequestCookies,\n  route?: string\n): Promise<ReadonlyRequestCookies> {\n  const cachedCookies = CachedCookies.get(underlyingCookies)\n  if (cachedCookies) {\n    return cachedCookies\n  }\n\n  const promise = new Promise<ReadonlyRequestCookies>((resolve) =>\n    scheduleImmediate(() => resolve(underlyingCookies))\n  )\n  CachedCookies.set(underlyingCookies, promise)\n\n  Object.defineProperties(promise, {\n    [Symbol.iterator]: {\n      value: function () {\n        const expression = '`...cookies()` or similar iteration'\n        syncIODev(route, expression)\n        return underlyingCookies[Symbol.iterator]\n          ? underlyingCookies[Symbol.iterator].apply(\n              underlyingCookies,\n              arguments as any\n            )\n          : // TODO this is a polyfill for when the underlying type is ResponseCookies\n            // We should remove this and unify our cookies types. We could just let this continue to throw lazily\n            // but that's already a hard thing to debug so we may as well implement it consistently. The biggest problem with\n            // implementing this in this way is the underlying cookie type is a ResponseCookie and not a RequestCookie and so it\n            // has extra properties not available on RequestCookie instances.\n            polyfilledResponseCookiesIterator.call(underlyingCookies)\n      },\n      writable: false,\n    },\n    size: {\n      get(): number {\n        const expression = '`cookies().size`'\n        syncIODev(route, expression)\n        return underlyingCookies.size\n      },\n    },\n    get: {\n      value: function get() {\n        let expression: string\n        if (arguments.length === 0) {\n          expression = '`cookies().get()`'\n        } else {\n          expression = `\\`cookies().get(${describeNameArg(arguments[0])})\\``\n        }\n        syncIODev(route, expression)\n        return underlyingCookies.get.apply(underlyingCookies, arguments as any)\n      },\n      writable: false,\n    },\n    getAll: {\n      value: function getAll() {\n        let expression: string\n        if (arguments.length === 0) {\n          expression = '`cookies().getAll()`'\n        } else {\n          expression = `\\`cookies().getAll(${describeNameArg(arguments[0])})\\``\n        }\n        syncIODev(route, expression)\n        return underlyingCookies.getAll.apply(\n          underlyingCookies,\n          arguments as any\n        )\n      },\n      writable: false,\n    },\n    has: {\n      value: function get() {\n        let expression: string\n        if (arguments.length === 0) {\n          expression = '`cookies().has()`'\n        } else {\n          expression = `\\`cookies().has(${describeNameArg(arguments[0])})\\``\n        }\n        syncIODev(route, expression)\n        return underlyingCookies.has.apply(underlyingCookies, arguments as any)\n      },\n      writable: false,\n    },\n    set: {\n      value: function set() {\n        let expression: string\n        if (arguments.length === 0) {\n          expression = '`cookies().set()`'\n        } else {\n          const arg = arguments[0]\n          if (arg) {\n            expression = `\\`cookies().set(${describeNameArg(arg)}, ...)\\``\n          } else {\n            expression = '`cookies().set(...)`'\n          }\n        }\n        syncIODev(route, expression)\n        return underlyingCookies.set.apply(underlyingCookies, arguments as any)\n      },\n      writable: false,\n    },\n    delete: {\n      value: function () {\n        let expression: string\n        if (arguments.length === 0) {\n          expression = '`cookies().delete()`'\n        } else if (arguments.length === 1) {\n          expression = `\\`cookies().delete(${describeNameArg(arguments[0])})\\``\n        } else {\n          expression = `\\`cookies().delete(${describeNameArg(arguments[0])}, ...)\\``\n        }\n        syncIODev(route, expression)\n        return underlyingCookies.delete.apply(\n          underlyingCookies,\n          arguments as any\n        )\n      },\n      writable: false,\n    },\n    clear: {\n      value: function clear() {\n        const expression = '`cookies().clear()`'\n        syncIODev(route, expression)\n        // @ts-ignore clear is defined in RequestCookies implementation but not in the type\n        return typeof underlyingCookies.clear === 'function'\n          ? // @ts-ignore clear is defined in RequestCookies implementation but not in the type\n            underlyingCookies.clear.apply(underlyingCookies, arguments)\n          : // TODO this is a polyfill for when the underlying type is ResponseCookies\n            // We should remove this and unify our cookies types. We could just let this continue to throw lazily\n            // but that's already a hard thing to debug so we may as well implement it consistently. The biggest problem with\n            // implementing this in this way is the underlying cookie type is a ResponseCookie and not a RequestCookie and so it\n            // has extra properties not available on RequestCookie instances.\n            polyfilledResponseCookiesClear.call(underlyingCookies, promise)\n      },\n      writable: false,\n    },\n    toString: {\n      value: function toString() {\n        const expression = '`cookies().toString()` or implicit casting'\n        syncIODev(route, expression)\n        return underlyingCookies.toString.apply(\n          underlyingCookies,\n          arguments as any\n        )\n      },\n      writable: false,\n    },\n  } satisfies CookieExtensions)\n\n  return promise\n}\n\n// Similar to `makeUntrackedExoticCookiesWithDevWarnings`, but just logging the\n// sync access without actually defining the cookies properties on the promise.\nfunction makeUntrackedCookiesWithDevWarnings(\n  underlyingCookies: ReadonlyRequestCookies,\n  route?: string\n): Promise<ReadonlyRequestCookies> {\n  const cachedCookies = CachedCookies.get(underlyingCookies)\n  if (cachedCookies) {\n    return cachedCookies\n  }\n\n  const promise = new Promise<ReadonlyRequestCookies>((resolve) =>\n    scheduleImmediate(() => resolve(underlyingCookies))\n  )\n\n  const proxiedPromise = new Proxy(promise, {\n    get(target, prop, receiver) {\n      switch (prop) {\n        case Symbol.iterator: {\n          warnForSyncAccess(route, '`...cookies()` or similar iteration')\n          break\n        }\n        case 'size':\n        case 'get':\n        case 'getAll':\n        case 'has':\n        case 'set':\n        case 'delete':\n        case 'clear':\n        case 'toString': {\n          warnForSyncAccess(route, `\\`cookies().${prop}\\``)\n          break\n        }\n        default: {\n          // We only warn for well-defined properties of the cookies object.\n        }\n      }\n\n      return ReflectAdapter.get(target, prop, receiver)\n    },\n  })\n\n  CachedCookies.set(underlyingCookies, proxiedPromise)\n\n  return proxiedPromise\n}\n\nfunction describeNameArg(arg: unknown) {\n  return typeof arg === 'object' &&\n    arg !== null &&\n    typeof (arg as any).name === 'string'\n    ? `'${(arg as any).name}'`\n    : typeof arg === 'string'\n      ? `'${arg}'`\n      : '...'\n}\n\nfunction syncIODev(route: string | undefined, expression: string) {\n  const workUnitStore = workUnitAsyncStorage.getStore()\n  if (\n    workUnitStore &&\n    workUnitStore.type === 'request' &&\n    workUnitStore.prerenderPhase === true\n  ) {\n    // When we're rendering dynamically in dev we need to advance out of the\n    // Prerender environment when we read Request data synchronously\n    const requestStore = workUnitStore\n    trackSynchronousRequestDataAccessInDev(requestStore)\n  }\n  // In all cases we warn normally\n  warnForSyncAccess(route, expression)\n}\n\nconst warnForSyncAccess = createDedupedByCallsiteServerErrorLoggerDev(\n  createCookiesAccessError\n)\n\nfunction createCookiesAccessError(\n  route: string | undefined,\n  expression: string\n) {\n  const prefix = route ? `Route \"${route}\" ` : 'This route '\n  return new Error(\n    `${prefix}used ${expression}. ` +\n      `\\`cookies()\\` should be awaited before using its value. ` +\n      `Learn more: https://nextjs.org/docs/messages/sync-dynamic-apis`\n  )\n}\n\nfunction polyfilledResponseCookiesIterator(\n  this: ResponseCookies\n): ReturnType<ReadonlyRequestCookies[typeof Symbol.iterator]> {\n  return this.getAll()\n    .map((c) => [c.name, c] as [string, any])\n    .values()\n}\n\nfunction polyfilledResponseCookiesClear(\n  this: ResponseCookies,\n  returnable: Promise<ReadonlyRequestCookies>\n): typeof returnable {\n  for (const cookie of this.getAll()) {\n    this.delete(cookie.name)\n  }\n  return returnable\n}\n\ntype CookieExtensions = {\n  [K in keyof ReadonlyRequestCookies | 'clear']: unknown\n}\n"],"names":["cookies","callingExpression","workStore","workAsyncStorage","getStore","workUnitStore","workUnitAsyncStorage","phase","isRequestAPICallableInsideAfter","Error","route","forceStatic","underlyingCookies","createEmptyCookies","makeUntrackedExoticCookies","type","dynamicShouldError","StaticGenBailoutError","makeHangingCookies","exportName","InvariantError","postponeWithTracking","dynamicTracking","throwToInterruptStaticGeneration","trackDynamicDataInDynamicRender","requestStore","getExpectedRequestStore","areCookiesMutableInCurrentPhase","userspaceMutableCookies","process","env","NODE_ENV","isPrefetchRequest","__NEXT_DYNAMIC_IO","makeUntrackedCookiesWithDevWarnings","makeUntrackedExoticCookiesWithDevWarnings","RequestCookiesAdapter","seal","RequestCookies","Headers","CachedCookies","WeakMap","prerenderStore","cachedPromise","get","promise","makeHangingPromise","renderSignal","set","cachedCookies","Promise","resolve","Object","defineProperties","Symbol","iterator","value","bind","polyfilledResponseCookiesIterator","size","getAll","has","delete","clear","polyfilledResponseCookiesClear","toString","scheduleImmediate","expression","syncIODev","apply","arguments","call","writable","length","describeNameArg","arg","proxiedPromise","Proxy","target","prop","receiver","warnForSyncAccess","ReflectAdapter","name","prerenderPhase","trackSynchronousRequestDataAccessInDev","createDedupedByCallsiteServerErrorLoggerDev","createCookiesAccessError","prefix","map","c","values","returnable","cookie"],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 1894, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/lenovo/Desktop/LinkdinClone/frontend/node_modules/next/src/server/web/spec-extension/adapters/headers.ts"],"sourcesContent":["import type { IncomingHttpHeaders } from 'http'\n\nimport { ReflectAdapter } from './reflect'\n\n/**\n * @internal\n */\nexport class ReadonlyHeadersError extends Error {\n  constructor() {\n    super(\n      'Headers cannot be modified. Read more: https://nextjs.org/docs/app/api-reference/functions/headers'\n    )\n  }\n\n  public static callable() {\n    throw new ReadonlyHeadersError()\n  }\n}\n\nexport type ReadonlyHeaders = Headers & {\n  /** @deprecated Method unavailable on `ReadonlyHeaders`. Read more: https://nextjs.org/docs/app/api-reference/functions/headers */\n  append(...args: any[]): void\n  /** @deprecated Method unavailable on `ReadonlyHeaders`. Read more: https://nextjs.org/docs/app/api-reference/functions/headers */\n  set(...args: any[]): void\n  /** @deprecated Method unavailable on `ReadonlyHeaders`. Read more: https://nextjs.org/docs/app/api-reference/functions/headers */\n  delete(...args: any[]): void\n}\nexport class HeadersAdapter extends Headers {\n  private readonly headers: IncomingHttpHeaders\n\n  constructor(headers: IncomingHttpHeaders) {\n    // We've already overridden the methods that would be called, so we're just\n    // calling the super constructor to ensure that the instanceof check works.\n    super()\n\n    this.headers = new Proxy(headers, {\n      get(target, prop, receiver) {\n        // Because this is just an object, we expect that all \"get\" operations\n        // are for properties. If it's a \"get\" for a symbol, we'll just return\n        // the symbol.\n        if (typeof prop === 'symbol') {\n          return ReflectAdapter.get(target, prop, receiver)\n        }\n\n        const lowercased = prop.toLowerCase()\n\n        // Let's find the original casing of the key. This assumes that there is\n        // no mixed case keys (e.g. \"Content-Type\" and \"content-type\") in the\n        // headers object.\n        const original = Object.keys(headers).find(\n          (o) => o.toLowerCase() === lowercased\n        )\n\n        // If the original casing doesn't exist, return undefined.\n        if (typeof original === 'undefined') return\n\n        // If the original casing exists, return the value.\n        return ReflectAdapter.get(target, original, receiver)\n      },\n      set(target, prop, value, receiver) {\n        if (typeof prop === 'symbol') {\n          return ReflectAdapter.set(target, prop, value, receiver)\n        }\n\n        const lowercased = prop.toLowerCase()\n\n        // Let's find the original casing of the key. This assumes that there is\n        // no mixed case keys (e.g. \"Content-Type\" and \"content-type\") in the\n        // headers object.\n        const original = Object.keys(headers).find(\n          (o) => o.toLowerCase() === lowercased\n        )\n\n        // If the original casing doesn't exist, use the prop as the key.\n        return ReflectAdapter.set(target, original ?? prop, value, receiver)\n      },\n      has(target, prop) {\n        if (typeof prop === 'symbol') return ReflectAdapter.has(target, prop)\n\n        const lowercased = prop.toLowerCase()\n\n        // Let's find the original casing of the key. This assumes that there is\n        // no mixed case keys (e.g. \"Content-Type\" and \"content-type\") in the\n        // headers object.\n        const original = Object.keys(headers).find(\n          (o) => o.toLowerCase() === lowercased\n        )\n\n        // If the original casing doesn't exist, return false.\n        if (typeof original === 'undefined') return false\n\n        // If the original casing exists, return true.\n        return ReflectAdapter.has(target, original)\n      },\n      deleteProperty(target, prop) {\n        if (typeof prop === 'symbol')\n          return ReflectAdapter.deleteProperty(target, prop)\n\n        const lowercased = prop.toLowerCase()\n\n        // Let's find the original casing of the key. This assumes that there is\n        // no mixed case keys (e.g. \"Content-Type\" and \"content-type\") in the\n        // headers object.\n        const original = Object.keys(headers).find(\n          (o) => o.toLowerCase() === lowercased\n        )\n\n        // If the original casing doesn't exist, return true.\n        if (typeof original === 'undefined') return true\n\n        // If the original casing exists, delete the property.\n        return ReflectAdapter.deleteProperty(target, original)\n      },\n    })\n  }\n\n  /**\n   * Seals a Headers instance to prevent modification by throwing an error when\n   * any mutating method is called.\n   */\n  public static seal(headers: Headers): ReadonlyHeaders {\n    return new Proxy<ReadonlyHeaders>(headers, {\n      get(target, prop, receiver) {\n        switch (prop) {\n          case 'append':\n          case 'delete':\n          case 'set':\n            return ReadonlyHeadersError.callable\n          default:\n            return ReflectAdapter.get(target, prop, receiver)\n        }\n      },\n    })\n  }\n\n  /**\n   * Merges a header value into a string. This stores multiple values as an\n   * array, so we need to merge them into a string.\n   *\n   * @param value a header value\n   * @returns a merged header value (a string)\n   */\n  private merge(value: string | string[]): string {\n    if (Array.isArray(value)) return value.join(', ')\n\n    return value\n  }\n\n  /**\n   * Creates a Headers instance from a plain object or a Headers instance.\n   *\n   * @param headers a plain object or a Headers instance\n   * @returns a headers instance\n   */\n  public static from(headers: IncomingHttpHeaders | Headers): Headers {\n    if (headers instanceof Headers) return headers\n\n    return new HeadersAdapter(headers)\n  }\n\n  public append(name: string, value: string): void {\n    const existing = this.headers[name]\n    if (typeof existing === 'string') {\n      this.headers[name] = [existing, value]\n    } else if (Array.isArray(existing)) {\n      existing.push(value)\n    } else {\n      this.headers[name] = value\n    }\n  }\n\n  public delete(name: string): void {\n    delete this.headers[name]\n  }\n\n  public get(name: string): string | null {\n    const value = this.headers[name]\n    if (typeof value !== 'undefined') return this.merge(value)\n\n    return null\n  }\n\n  public has(name: string): boolean {\n    return typeof this.headers[name] !== 'undefined'\n  }\n\n  public set(name: string, value: string): void {\n    this.headers[name] = value\n  }\n\n  public forEach(\n    callbackfn: (value: string, name: string, parent: Headers) => void,\n    thisArg?: any\n  ): void {\n    for (const [name, value] of this.entries()) {\n      callbackfn.call(thisArg, value, name, this)\n    }\n  }\n\n  public *entries(): HeadersIterator<[string, string]> {\n    for (const key of Object.keys(this.headers)) {\n      const name = key.toLowerCase()\n      // We assert here that this is a string because we got it from the\n      // Object.keys() call above.\n      const value = this.get(name) as string\n\n      yield [name, value] as [string, string]\n    }\n  }\n\n  public *keys(): HeadersIterator<string> {\n    for (const key of Object.keys(this.headers)) {\n      const name = key.toLowerCase()\n      yield name\n    }\n  }\n\n  public *values(): HeadersIterator<string> {\n    for (const key of Object.keys(this.headers)) {\n      // We assert here that this is a string because we got it from the\n      // Object.keys() call above.\n      const value = this.get(key) as string\n\n      yield value\n    }\n  }\n\n  public [Symbol.iterator](): HeadersIterator<[string, string]> {\n    return this.entries()\n  }\n}\n"],"names":["HeadersAdapter","ReadonlyHeadersError","Error","constructor","callable","Headers","headers","Proxy","get","target","prop","receiver","ReflectAdapter","lowercased","toLowerCase","original","Object","keys","find","o","set","value","has","deleteProperty","seal","merge","Array","isArray","join","from","append","name","existing","push","delete","forEach","callbackfn","thisArg","entries","call","key","values","Symbol","iterator"],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 2089, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/lenovo/Desktop/LinkdinClone/frontend/node_modules/next/src/server/request/headers.ts"],"sourcesContent":["import {\n  HeadersAdapter,\n  type ReadonlyHeaders,\n} from '../web/spec-extension/adapters/headers'\nimport { workAsyncStorage } from '../app-render/work-async-storage.external'\nimport { getExpectedRequestStore } from '../app-render/work-unit-async-storage.external'\nimport {\n  workUnitAsyncStorage,\n  type PrerenderStoreModern,\n} from '../app-render/work-unit-async-storage.external'\nimport {\n  postponeWithTracking,\n  throwToInterruptStaticGeneration,\n  trackDynamicDataInDynamicRender,\n  trackSynchronousRequestDataAccessInDev,\n} from '../app-render/dynamic-rendering'\nimport { StaticGenBailoutError } from '../../client/components/static-generation-bailout'\nimport { makeHangingPromise } from '../dynamic-rendering-utils'\nimport { createDedupedByCallsiteServerErrorLoggerDev } from '../create-deduped-by-callsite-server-error-logger'\nimport { scheduleImmediate } from '../../lib/scheduler'\nimport { isRequestAPICallableInsideAfter } from './utils'\nimport { InvariantError } from '../../shared/lib/invariant-error'\nimport { ReflectAdapter } from '../web/spec-extension/adapters/reflect'\n\n/**\n * In this version of Next.js `headers()` returns a Promise however you can still reference the properties of the underlying Headers instance\n * synchronously to facilitate migration. The `UnsafeUnwrappedHeaders` type is added to your code by a codemod that attempts to automatically\n * updates callsites to reflect the new Promise return type. There are some cases where `headers()` cannot be automatically converted, namely\n * when it is used inside a synchronous function and we can't be sure the function can be made async automatically. In these cases we add an\n * explicit type case to `UnsafeUnwrappedHeaders` to enable typescript to allow for the synchronous usage only where it is actually necessary.\n *\n * You should should update these callsites to either be async functions where the `headers()` value can be awaited or you should call `headers()`\n * from outside and await the return value before passing it into this function.\n *\n * You can find instances that require manual migration by searching for `UnsafeUnwrappedHeaders` in your codebase or by search for a comment that\n * starts with `@next-codemod-error`.\n *\n * In a future version of Next.js `headers()` will only return a Promise and you will not be able to access the underlying Headers instance\n * without awaiting the return value first. When this change happens the type `UnsafeUnwrappedHeaders` will be updated to reflect that is it no longer\n * usable.\n *\n * This type is marked deprecated to help identify it as target for refactoring away.\n *\n * @deprecated\n */\nexport type UnsafeUnwrappedHeaders = ReadonlyHeaders\n\n/**\n * This function allows you to read the HTTP incoming request headers in\n * [Server Components](https://nextjs.org/docs/app/building-your-application/rendering/server-components),\n * [Server Actions](https://nextjs.org/docs/app/building-your-application/data-fetching/server-actions-and-mutations),\n * [Route Handlers](https://nextjs.org/docs/app/building-your-application/routing/route-handlers) and\n * [Middleware](https://nextjs.org/docs/app/building-your-application/routing/middleware).\n *\n * Read more: [Next.js Docs: `headers`](https://nextjs.org/docs/app/api-reference/functions/headers)\n */\nexport function headers(): Promise<ReadonlyHeaders> {\n  const workStore = workAsyncStorage.getStore()\n  const workUnitStore = workUnitAsyncStorage.getStore()\n\n  if (workStore) {\n    if (\n      workUnitStore &&\n      workUnitStore.phase === 'after' &&\n      !isRequestAPICallableInsideAfter()\n    ) {\n      throw new Error(\n        `Route ${workStore.route} used \"headers\" inside \"after(...)\". This is not supported. If you need this data inside an \"after\" callback, use \"headers\" outside of the callback. See more info here: https://nextjs.org/docs/canary/app/api-reference/functions/after`\n      )\n    }\n\n    if (workStore.forceStatic) {\n      // When using forceStatic we override all other logic and always just return an empty\n      // headers object without tracking\n      const underlyingHeaders = HeadersAdapter.seal(new Headers({}))\n      return makeUntrackedExoticHeaders(underlyingHeaders)\n    }\n\n    if (workUnitStore) {\n      if (workUnitStore.type === 'cache') {\n        throw new Error(\n          `Route ${workStore.route} used \"headers\" inside \"use cache\". Accessing Dynamic data sources inside a cache scope is not supported. If you need this data inside a cached function use \"headers\" outside of the cached function and pass the required dynamic data in as an argument. See more info here: https://nextjs.org/docs/messages/next-request-in-use-cache`\n        )\n      } else if (workUnitStore.type === 'unstable-cache') {\n        throw new Error(\n          `Route ${workStore.route} used \"headers\" inside a function cached with \"unstable_cache(...)\". Accessing Dynamic data sources inside a cache scope is not supported. If you need this data inside a cached function use \"headers\" outside of the cached function and pass the required dynamic data in as an argument. See more info here: https://nextjs.org/docs/app/api-reference/functions/unstable_cache`\n        )\n      }\n    }\n    if (workStore.dynamicShouldError) {\n      throw new StaticGenBailoutError(\n        `Route ${workStore.route} with \\`dynamic = \"error\"\\` couldn't be rendered statically because it used \\`headers\\`. See more info here: https://nextjs.org/docs/app/building-your-application/rendering/static-and-dynamic#dynamic-rendering`\n      )\n    }\n\n    if (workUnitStore) {\n      switch (workUnitStore.type) {\n        case 'prerender':\n          return makeHangingHeaders(workUnitStore)\n        case 'prerender-client':\n          const exportName = '`headers`'\n          throw new InvariantError(\n            `${exportName} must not be used within a client component. Next.js should be preventing ${exportName} from being included in client components statically, but did not in this case.`\n          )\n        case 'prerender-ppr':\n          // PPR Prerender (no dynamicIO)\n          // We are prerendering with PPR. We need track dynamic access here eagerly\n          // to keep continuity with how headers has worked in PPR without dynamicIO.\n          // TODO consider switching the semantic to throw on property access instead\n          postponeWithTracking(\n            workStore.route,\n            'headers',\n            workUnitStore.dynamicTracking\n          )\n          break\n        case 'prerender-legacy':\n          // Legacy Prerender\n          // We are in a legacy static generation mode while prerendering\n          // We track dynamic access here so we don't need to wrap the headers in\n          // individual property access tracking.\n          throwToInterruptStaticGeneration('headers', workStore, workUnitStore)\n          break\n        default:\n        // fallthrough\n      }\n    }\n    // We fall through to the dynamic context below but we still track dynamic access\n    // because in dev we can still error for things like using headers inside a cache context\n    trackDynamicDataInDynamicRender(workStore, workUnitStore)\n  }\n\n  const requestStore = getExpectedRequestStore('headers')\n  if (process.env.NODE_ENV === 'development' && !workStore?.isPrefetchRequest) {\n    if (process.env.__NEXT_DYNAMIC_IO) {\n      return makeUntrackedHeadersWithDevWarnings(\n        requestStore.headers,\n        workStore?.route\n      )\n    }\n\n    return makeUntrackedExoticHeadersWithDevWarnings(\n      requestStore.headers,\n      workStore?.route\n    )\n  } else {\n    return makeUntrackedExoticHeaders(requestStore.headers)\n  }\n}\n\ninterface CacheLifetime {}\nconst CachedHeaders = new WeakMap<CacheLifetime, Promise<ReadonlyHeaders>>()\n\nfunction makeHangingHeaders(\n  prerenderStore: PrerenderStoreModern\n): Promise<ReadonlyHeaders> {\n  const cachedHeaders = CachedHeaders.get(prerenderStore)\n  if (cachedHeaders) {\n    return cachedHeaders\n  }\n\n  const promise = makeHangingPromise<ReadonlyHeaders>(\n    prerenderStore.renderSignal,\n    '`headers()`'\n  )\n  CachedHeaders.set(prerenderStore, promise)\n\n  return promise\n}\n\nfunction makeUntrackedExoticHeaders(\n  underlyingHeaders: ReadonlyHeaders\n): Promise<ReadonlyHeaders> {\n  const cachedHeaders = CachedHeaders.get(underlyingHeaders)\n  if (cachedHeaders) {\n    return cachedHeaders\n  }\n\n  const promise = Promise.resolve(underlyingHeaders)\n  CachedHeaders.set(underlyingHeaders, promise)\n\n  Object.defineProperties(promise, {\n    append: {\n      value: underlyingHeaders.append.bind(underlyingHeaders),\n    },\n    delete: {\n      value: underlyingHeaders.delete.bind(underlyingHeaders),\n    },\n    get: {\n      value: underlyingHeaders.get.bind(underlyingHeaders),\n    },\n    has: {\n      value: underlyingHeaders.has.bind(underlyingHeaders),\n    },\n    set: {\n      value: underlyingHeaders.set.bind(underlyingHeaders),\n    },\n    getSetCookie: {\n      value: underlyingHeaders.getSetCookie.bind(underlyingHeaders),\n    },\n    forEach: {\n      value: underlyingHeaders.forEach.bind(underlyingHeaders),\n    },\n    keys: {\n      value: underlyingHeaders.keys.bind(underlyingHeaders),\n    },\n    values: {\n      value: underlyingHeaders.values.bind(underlyingHeaders),\n    },\n    entries: {\n      value: underlyingHeaders.entries.bind(underlyingHeaders),\n    },\n    [Symbol.iterator]: {\n      value: underlyingHeaders[Symbol.iterator].bind(underlyingHeaders),\n    },\n  } satisfies HeadersExtensions)\n\n  return promise\n}\n\nfunction makeUntrackedExoticHeadersWithDevWarnings(\n  underlyingHeaders: ReadonlyHeaders,\n  route?: string\n): Promise<ReadonlyHeaders> {\n  const cachedHeaders = CachedHeaders.get(underlyingHeaders)\n  if (cachedHeaders) {\n    return cachedHeaders\n  }\n\n  const promise = new Promise<ReadonlyHeaders>((resolve) =>\n    scheduleImmediate(() => resolve(underlyingHeaders))\n  )\n\n  CachedHeaders.set(underlyingHeaders, promise)\n\n  Object.defineProperties(promise, {\n    append: {\n      value: function append() {\n        const expression = `\\`headers().append(${describeNameArg(arguments[0])}, ...)\\``\n        syncIODev(route, expression)\n        return underlyingHeaders.append.apply(\n          underlyingHeaders,\n          arguments as any\n        )\n      },\n    },\n    delete: {\n      value: function _delete() {\n        const expression = `\\`headers().delete(${describeNameArg(arguments[0])})\\``\n        syncIODev(route, expression)\n        return underlyingHeaders.delete.apply(\n          underlyingHeaders,\n          arguments as any\n        )\n      },\n    },\n    get: {\n      value: function get() {\n        const expression = `\\`headers().get(${describeNameArg(arguments[0])})\\``\n        syncIODev(route, expression)\n        return underlyingHeaders.get.apply(underlyingHeaders, arguments as any)\n      },\n    },\n    has: {\n      value: function has() {\n        const expression = `\\`headers().has(${describeNameArg(arguments[0])})\\``\n        syncIODev(route, expression)\n        return underlyingHeaders.has.apply(underlyingHeaders, arguments as any)\n      },\n    },\n    set: {\n      value: function set() {\n        const expression = `\\`headers().set(${describeNameArg(arguments[0])}, ...)\\``\n        syncIODev(route, expression)\n        return underlyingHeaders.set.apply(underlyingHeaders, arguments as any)\n      },\n    },\n    getSetCookie: {\n      value: function getSetCookie() {\n        const expression = '`headers().getSetCookie()`'\n        syncIODev(route, expression)\n        return underlyingHeaders.getSetCookie.apply(\n          underlyingHeaders,\n          arguments as any\n        )\n      },\n    },\n    forEach: {\n      value: function forEach() {\n        const expression = '`headers().forEach(...)`'\n        syncIODev(route, expression)\n        return underlyingHeaders.forEach.apply(\n          underlyingHeaders,\n          arguments as any\n        )\n      },\n    },\n    keys: {\n      value: function keys() {\n        const expression = '`headers().keys()`'\n        syncIODev(route, expression)\n        return underlyingHeaders.keys.apply(underlyingHeaders, arguments as any)\n      },\n    },\n    values: {\n      value: function values() {\n        const expression = '`headers().values()`'\n        syncIODev(route, expression)\n        return underlyingHeaders.values.apply(\n          underlyingHeaders,\n          arguments as any\n        )\n      },\n    },\n    entries: {\n      value: function entries() {\n        const expression = '`headers().entries()`'\n        syncIODev(route, expression)\n        return underlyingHeaders.entries.apply(\n          underlyingHeaders,\n          arguments as any\n        )\n      },\n    },\n    [Symbol.iterator]: {\n      value: function () {\n        const expression = '`...headers()` or similar iteration'\n        syncIODev(route, expression)\n        return underlyingHeaders[Symbol.iterator].apply(\n          underlyingHeaders,\n          arguments as any\n        )\n      },\n    },\n  } satisfies HeadersExtensions)\n\n  return promise\n}\n\n// Similar to `makeUntrackedExoticHeadersWithDevWarnings`, but just logging the\n// sync access without actually defining the headers properties on the promise.\nfunction makeUntrackedHeadersWithDevWarnings(\n  underlyingHeaders: ReadonlyHeaders,\n  route?: string\n): Promise<ReadonlyHeaders> {\n  const cachedHeaders = CachedHeaders.get(underlyingHeaders)\n  if (cachedHeaders) {\n    return cachedHeaders\n  }\n\n  const promise = new Promise<ReadonlyHeaders>((resolve) =>\n    scheduleImmediate(() => resolve(underlyingHeaders))\n  )\n\n  const proxiedPromise = new Proxy(promise, {\n    get(target, prop, receiver) {\n      switch (prop) {\n        case Symbol.iterator: {\n          warnForSyncAccess(route, '`...headers()` or similar iteration')\n          break\n        }\n        case 'append':\n        case 'delete':\n        case 'get':\n        case 'has':\n        case 'set':\n        case 'getSetCookie':\n        case 'forEach':\n        case 'keys':\n        case 'values':\n        case 'entries': {\n          warnForSyncAccess(route, `\\`headers().${prop}\\``)\n          break\n        }\n        default: {\n          // We only warn for well-defined properties of the headers object.\n        }\n      }\n\n      return ReflectAdapter.get(target, prop, receiver)\n    },\n  })\n\n  CachedHeaders.set(underlyingHeaders, proxiedPromise)\n\n  return proxiedPromise\n}\n\nfunction describeNameArg(arg: unknown) {\n  return typeof arg === 'string' ? `'${arg}'` : '...'\n}\n\nfunction syncIODev(route: string | undefined, expression: string) {\n  const workUnitStore = workUnitAsyncStorage.getStore()\n  if (\n    workUnitStore &&\n    workUnitStore.type === 'request' &&\n    workUnitStore.prerenderPhase === true\n  ) {\n    // When we're rendering dynamically in dev we need to advance out of the\n    // Prerender environment when we read Request data synchronously\n    const requestStore = workUnitStore\n    trackSynchronousRequestDataAccessInDev(requestStore)\n  }\n  // In all cases we warn normally\n  warnForSyncAccess(route, expression)\n}\n\nconst warnForSyncAccess = createDedupedByCallsiteServerErrorLoggerDev(\n  createHeadersAccessError\n)\n\nfunction createHeadersAccessError(\n  route: string | undefined,\n  expression: string\n) {\n  const prefix = route ? `Route \"${route}\" ` : 'This route '\n  return new Error(\n    `${prefix}used ${expression}. ` +\n      `\\`headers()\\` should be awaited before using its value. ` +\n      `Learn more: https://nextjs.org/docs/messages/sync-dynamic-apis`\n  )\n}\n\ntype HeadersExtensions = {\n  [K in keyof ReadonlyHeaders]: unknown\n}\n"],"names":["headers","workStore","workAsyncStorage","getStore","workUnitStore","workUnitAsyncStorage","phase","isRequestAPICallableInsideAfter","Error","route","forceStatic","underlyingHeaders","HeadersAdapter","seal","Headers","makeUntrackedExoticHeaders","type","dynamicShouldError","StaticGenBailoutError","makeHangingHeaders","exportName","InvariantError","postponeWithTracking","dynamicTracking","throwToInterruptStaticGeneration","trackDynamicDataInDynamicRender","requestStore","getExpectedRequestStore","process","env","NODE_ENV","isPrefetchRequest","__NEXT_DYNAMIC_IO","makeUntrackedHeadersWithDevWarnings","makeUntrackedExoticHeadersWithDevWarnings","CachedHeaders","WeakMap","prerenderStore","cachedHeaders","get","promise","makeHangingPromise","renderSignal","set","Promise","resolve","Object","defineProperties","append","value","bind","delete","has","getSetCookie","forEach","keys","values","entries","Symbol","iterator","scheduleImmediate","expression","describeNameArg","arguments","syncIODev","apply","_delete","proxiedPromise","Proxy","target","prop","receiver","warnForSyncAccess","ReflectAdapter","arg","prerenderPhase","trackSynchronousRequestDataAccessInDev","createDedupedByCallsiteServerErrorLoggerDev","createHeadersAccessError","prefix"],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 2403, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/lenovo/Desktop/LinkdinClone/frontend/node_modules/next/src/server/request/draft-mode.ts"],"sourcesContent":["import {\n  getDraftModeProviderForCacheScope,\n  throwForMissingRequestStore,\n} from '../app-render/work-unit-async-storage.external'\n\nimport type { DraftModeProvider } from '../async-storage/draft-mode-provider'\n\nimport {\n  workAsyncStorage,\n  type WorkStore,\n} from '../app-render/work-async-storage.external'\nimport { workUnitAsyncStorage } from '../app-render/work-unit-async-storage.external'\nimport {\n  abortAndThrowOnSynchronousRequestDataAccess,\n  postponeWithTracking,\n  trackSynchronousRequestDataAccessInDev,\n} from '../app-render/dynamic-rendering'\nimport { createDedupedByCallsiteServerErrorLoggerDev } from '../create-deduped-by-callsite-server-error-logger'\nimport { StaticGenBailoutError } from '../../client/components/static-generation-bailout'\nimport { DynamicServerError } from '../../client/components/hooks-server-context'\nimport { InvariantError } from '../../shared/lib/invariant-error'\nimport { ReflectAdapter } from '../web/spec-extension/adapters/reflect'\n\n/**\n * In this version of Next.js `draftMode()` returns a Promise however you can still reference the properties of the underlying draftMode object\n * synchronously to facilitate migration. The `UnsafeUnwrappedDraftMode` type is added to your code by a codemod that attempts to automatically\n * updates callsites to reflect the new Promise return type. There are some cases where `draftMode()` cannot be automatically converted, namely\n * when it is used inside a synchronous function and we can't be sure the function can be made async automatically. In these cases we add an\n * explicit type case to `UnsafeUnwrappedDraftMode` to enable typescript to allow for the synchronous usage only where it is actually necessary.\n *\n * You should should update these callsites to either be async functions where the `draftMode()` value can be awaited or you should call `draftMode()`\n * from outside and await the return value before passing it into this function.\n *\n * You can find instances that require manual migration by searching for `UnsafeUnwrappedDraftMode` in your codebase or by search for a comment that\n * starts with `@next-codemod-error`.\n *\n * In a future version of Next.js `draftMode()` will only return a Promise and you will not be able to access the underlying draftMode object directly\n * without awaiting the return value first. When this change happens the type `UnsafeUnwrappedDraftMode` will be updated to reflect that is it no longer\n * usable.\n *\n * This type is marked deprecated to help identify it as target for refactoring away.\n *\n * @deprecated\n */\nexport type UnsafeUnwrappedDraftMode = DraftMode\n\nexport function draftMode(): Promise<DraftMode> {\n  const callingExpression = 'draftMode'\n  const workStore = workAsyncStorage.getStore()\n  const workUnitStore = workUnitAsyncStorage.getStore()\n\n  if (!workStore || !workUnitStore) {\n    throwForMissingRequestStore(callingExpression)\n  }\n\n  switch (workUnitStore.type) {\n    case 'request':\n      return createOrGetCachedDraftMode(workUnitStore.draftMode, workStore)\n\n    case 'cache':\n    case 'unstable-cache':\n      // Inside of `\"use cache\"` or `unstable_cache`, draft mode is available if\n      // the outmost work unit store is a request store, and if draft mode is\n      // enabled.\n      const draftModeProvider = getDraftModeProviderForCacheScope(\n        workStore,\n        workUnitStore\n      )\n\n      if (draftModeProvider) {\n        return createOrGetCachedDraftMode(draftModeProvider, workStore)\n      }\n\n    // Otherwise, we fall through to providing an empty draft mode.\n    // eslint-disable-next-line no-fallthrough\n    case 'prerender':\n    case 'prerender-client':\n    case 'prerender-ppr':\n    case 'prerender-legacy':\n      // Return empty draft mode\n      return createOrGetCachedDraftMode(null, workStore)\n\n    default:\n      const _exhaustiveCheck: never = workUnitStore\n      return _exhaustiveCheck\n  }\n}\n\nfunction createOrGetCachedDraftMode(\n  draftModeProvider: DraftModeProvider | null,\n  workStore: WorkStore | undefined\n): Promise<DraftMode> {\n  const cacheKey = draftModeProvider ?? NullDraftMode\n  const cachedDraftMode = CachedDraftModes.get(cacheKey)\n\n  if (cachedDraftMode) {\n    return cachedDraftMode\n  }\n\n  let promise: Promise<DraftMode>\n\n  if (process.env.NODE_ENV === 'development' && !workStore?.isPrefetchRequest) {\n    const route = workStore?.route\n\n    if (process.env.__NEXT_DYNAMIC_IO) {\n      return createDraftModeWithDevWarnings(draftModeProvider, route)\n    }\n\n    promise = createExoticDraftModeWithDevWarnings(draftModeProvider, route)\n  } else {\n    if (process.env.__NEXT_DYNAMIC_IO) {\n      return Promise.resolve(new DraftMode(draftModeProvider))\n    }\n\n    promise = createExoticDraftMode(draftModeProvider)\n  }\n\n  CachedDraftModes.set(cacheKey, promise)\n\n  return promise\n}\n\ninterface CacheLifetime {}\nconst NullDraftMode = {}\nconst CachedDraftModes = new WeakMap<CacheLifetime, Promise<DraftMode>>()\n\nfunction createExoticDraftMode(\n  underlyingProvider: null | DraftModeProvider\n): Promise<DraftMode> {\n  const instance = new DraftMode(underlyingProvider)\n  const promise = Promise.resolve(instance)\n\n  Object.defineProperty(promise, 'isEnabled', {\n    get() {\n      return instance.isEnabled\n    },\n    enumerable: true,\n    configurable: true,\n  })\n  ;(promise as any).enable = instance.enable.bind(instance)\n  ;(promise as any).disable = instance.disable.bind(instance)\n\n  return promise\n}\n\nfunction createExoticDraftModeWithDevWarnings(\n  underlyingProvider: null | DraftModeProvider,\n  route: undefined | string\n): Promise<DraftMode> {\n  const instance = new DraftMode(underlyingProvider)\n  const promise = Promise.resolve(instance)\n\n  Object.defineProperty(promise, 'isEnabled', {\n    get() {\n      const expression = '`draftMode().isEnabled`'\n      syncIODev(route, expression)\n      return instance.isEnabled\n    },\n    enumerable: true,\n    configurable: true,\n  })\n\n  Object.defineProperty(promise, 'enable', {\n    value: function get() {\n      const expression = '`draftMode().enable()`'\n      syncIODev(route, expression)\n      return instance.enable.apply(instance, arguments as any)\n    },\n  })\n\n  Object.defineProperty(promise, 'disable', {\n    value: function get() {\n      const expression = '`draftMode().disable()`'\n      syncIODev(route, expression)\n      return instance.disable.apply(instance, arguments as any)\n    },\n  })\n\n  return promise\n}\n\n// Similar to `createExoticDraftModeWithDevWarnings`, but just logging the sync\n// access without actually defining the draftMode properties on the promise.\nfunction createDraftModeWithDevWarnings(\n  underlyingProvider: null | DraftModeProvider,\n  route: undefined | string\n): Promise<DraftMode> {\n  const instance = new DraftMode(underlyingProvider)\n  const promise = Promise.resolve(instance)\n\n  const proxiedPromise = new Proxy(promise, {\n    get(target, prop, receiver) {\n      switch (prop) {\n        case 'isEnabled':\n          warnForSyncAccess(route, `\\`draftMode().${prop}\\``)\n          break\n        case 'enable':\n        case 'disable': {\n          warnForSyncAccess(route, `\\`draftMode().${prop}()\\``)\n          break\n        }\n        default: {\n          // We only warn for well-defined properties of the draftMode object.\n        }\n      }\n\n      return ReflectAdapter.get(target, prop, receiver)\n    },\n  })\n\n  return proxiedPromise\n}\n\nclass DraftMode {\n  /**\n   * @internal - this declaration is stripped via `tsc --stripInternal`\n   */\n  private readonly _provider: null | DraftModeProvider\n\n  constructor(provider: null | DraftModeProvider) {\n    this._provider = provider\n  }\n  get isEnabled() {\n    if (this._provider !== null) {\n      return this._provider.isEnabled\n    }\n    return false\n  }\n  public enable() {\n    // We have a store we want to track dynamic data access to ensure we\n    // don't statically generate routes that manipulate draft mode.\n    trackDynamicDraftMode('draftMode().enable()')\n    if (this._provider !== null) {\n      this._provider.enable()\n    }\n  }\n  public disable() {\n    trackDynamicDraftMode('draftMode().disable()')\n    if (this._provider !== null) {\n      this._provider.disable()\n    }\n  }\n}\n\nfunction syncIODev(route: string | undefined, expression: string) {\n  const workUnitStore = workUnitAsyncStorage.getStore()\n  if (\n    workUnitStore &&\n    workUnitStore.type === 'request' &&\n    workUnitStore.prerenderPhase === true\n  ) {\n    // When we're rendering dynamically in dev we need to advance out of the\n    // Prerender environment when we read Request data synchronously\n    const requestStore = workUnitStore\n    trackSynchronousRequestDataAccessInDev(requestStore)\n  }\n  // In all cases we warn normally\n  warnForSyncAccess(route, expression)\n}\n\nconst warnForSyncAccess = createDedupedByCallsiteServerErrorLoggerDev(\n  createDraftModeAccessError\n)\n\nfunction createDraftModeAccessError(\n  route: string | undefined,\n  expression: string\n) {\n  const prefix = route ? `Route \"${route}\" ` : 'This route '\n  return new Error(\n    `${prefix}used ${expression}. ` +\n      `\\`draftMode()\\` should be awaited before using its value. ` +\n      `Learn more: https://nextjs.org/docs/messages/sync-dynamic-apis`\n  )\n}\n\nfunction trackDynamicDraftMode(expression: string) {\n  const store = workAsyncStorage.getStore()\n  const workUnitStore = workUnitAsyncStorage.getStore()\n  if (store) {\n    // We have a store we want to track dynamic data access to ensure we\n    // don't statically generate routes that manipulate draft mode.\n    if (workUnitStore) {\n      if (workUnitStore.type === 'cache') {\n        throw new Error(\n          `Route ${store.route} used \"${expression}\" inside \"use cache\". The enabled status of draftMode can be read in caches but you must not enable or disable draftMode inside a cache. See more info here: https://nextjs.org/docs/messages/next-request-in-use-cache`\n        )\n      } else if (workUnitStore.type === 'unstable-cache') {\n        throw new Error(\n          `Route ${store.route} used \"${expression}\" inside a function cached with \"unstable_cache(...)\". The enabled status of draftMode can be read in caches but you must not enable or disable draftMode inside a cache. See more info here: https://nextjs.org/docs/app/api-reference/functions/unstable_cache`\n        )\n      } else if (workUnitStore.phase === 'after') {\n        throw new Error(\n          `Route ${store.route} used \"${expression}\" inside \\`after\\`. The enabled status of draftMode can be read inside \\`after\\` but you cannot enable or disable draftMode. See more info here: https://nextjs.org/docs/app/api-reference/functions/after`\n        )\n      }\n    }\n\n    if (store.dynamicShouldError) {\n      throw new StaticGenBailoutError(\n        `Route ${store.route} with \\`dynamic = \"error\"\\` couldn't be rendered statically because it used \\`${expression}\\`. See more info here: https://nextjs.org/docs/app/building-your-application/rendering/static-and-dynamic#dynamic-rendering`\n      )\n    }\n\n    if (workUnitStore) {\n      switch (workUnitStore.type) {\n        case 'prerender':\n          // dynamicIO Prerender\n          const error = new Error(\n            `Route ${store.route} used ${expression} without first calling \\`await connection()\\`. See more info here: https://nextjs.org/docs/messages/next-prerender-sync-headers`\n          )\n          abortAndThrowOnSynchronousRequestDataAccess(\n            store.route,\n            expression,\n            error,\n            workUnitStore\n          )\n          break\n        case 'prerender-client':\n          const exportName = '`draftMode`'\n          throw new InvariantError(\n            `${exportName} must not be used within a client component. Next.js should be preventing ${exportName} from being included in client components statically, but did not in this case.`\n          )\n        case 'prerender-ppr':\n          // PPR Prerender\n          postponeWithTracking(\n            store.route,\n            expression,\n            workUnitStore.dynamicTracking\n          )\n          break\n        case 'prerender-legacy':\n          // legacy Prerender\n          workUnitStore.revalidate = 0\n\n          const err = new DynamicServerError(\n            `Route ${store.route} couldn't be rendered statically because it used \\`${expression}\\`. See more info here: https://nextjs.org/docs/messages/dynamic-server-error`\n          )\n          store.dynamicUsageDescription = expression\n          store.dynamicUsageStack = err.stack\n\n          throw err\n        case 'request':\n          if (process.env.NODE_ENV === 'development') {\n            workUnitStore.usedDynamic = true\n          }\n          break\n        default:\n        // fallthrough\n      }\n    }\n  }\n}\n"],"names":["draftMode","callingExpression","workStore","workAsyncStorage","getStore","workUnitStore","workUnitAsyncStorage","throwForMissingRequestStore","type","createOrGetCachedDraftMode","draftModeProvider","getDraftModeProviderForCacheScope","_exhaustiveCheck","cacheKey","NullDraftMode","cachedDraftMode","CachedDraftModes","get","promise","process","env","NODE_ENV","isPrefetchRequest","route","__NEXT_DYNAMIC_IO","createDraftModeWithDevWarnings","createExoticDraftModeWithDevWarnings","Promise","resolve","DraftMode","createExoticDraftMode","set","WeakMap","underlyingProvider","instance","Object","defineProperty","isEnabled","enumerable","configurable","enable","bind","disable","expression","syncIODev","value","apply","arguments","proxiedPromise","Proxy","target","prop","receiver","warnForSyncAccess","ReflectAdapter","constructor","provider","_provider","trackDynamicDraftMode","prerenderPhase","requestStore","trackSynchronousRequestDataAccessInDev","createDedupedByCallsiteServerErrorLoggerDev","createDraftModeAccessError","prefix","Error","store","phase","dynamicShouldError","StaticGenBailoutError","error","abortAndThrowOnSynchronousRequestDataAccess","exportName","InvariantError","postponeWithTracking","dynamicTracking","revalidate","err","DynamicServerError","dynamicUsageDescription","dynamicUsageStack","stack","usedDynamic"],"mappings":"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","ignoreList":[0],"debugId":null}}]
}